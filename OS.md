# 운영체제(OS)란?
![정의](/이미지/스크린샷%202024-03-14%20오전%2010.43.24.png)

운영체제란 컴퓨터에 포함된 cpu나 메모리, 입출력 기기등이 사용자의 기대에 맞게 역핳을 수행할 수 있도록 도와주는 창구역할을 하는 시스템 소프트웨어이다. 이러한 역할 때문에 '플랫폼 소프트웨어'라고도 불린다. 사용 기기나 목적에 따라 필요한 운영체제의 유형이 다르기 때문에 종류 또한 무척이나 다양하다.

## 운영체제의 대표적인 역할

- 프로세스 관리
- 메모리관리
- 파일 시스템 관리

## 운영체제의 구조
![구조](/이미지/스크린샷%202024-03-14%20오전%2010.52.15.png)

- `응용프로그램` :  사용자가 컴퓨터에서 특정 작업을 수행하기 위해 사용하는 소프트웨어입니다. 응용프로그램은 사용자가 원하는 작업을 수행하고 결과를 얻는 데 사용된다. 응용프로그램은 일반적으로 운영 체제 위에서 실행되며, 사용자가 그래픽 사용자 인터페이스(GUI)나 명령줄 인터페이스(CLI)를 통해 상호작용할 수 있다.
<br>
<br>
 
- `커널` : 커널은 컴퓨터 운영 체제의 핵심 부분으로, 하드웨어와 소프트웨어 간의 상호 작용을 관리하고 제어한다.
    - 주요 기능
        1. 자원관리
        2. 프로세스 관리
        3. 장치 드라이버 관리
        4. 메모리 관리
        5. 파일 시스템 관리

    - 인터페이스
        1. `CLI(Command Line Interface)`: 컴퓨터 프로그램과 사용자 간의 상호 작용을 위한 텍스트 기반 인터페이스. CLI는 사용자가 명령어를 입력하여 컴퓨터에 명령을 전달하고 결과를 받는 방식으로 동작한다. 텍스트 명령을 통해 파일을 생성, 복사, 이동, 삭제하거나 프로그램을 실행하는 등의 작업을 수행할 수 있다.
        CLI는 효율적인 작업 처리나 자동화된 작업을 위해 많이 사용됩니다. CLI는 텍스트 기반으로 작동하기 때문에 GUI보다 더 빠르고 자동화하기 쉽다는 장점이 있다.

        2. `GUI(Graphic User Interface)`: 사용자가 컴퓨터와 상호작용할 수 있도록 그래픽으로 구성된 환경을 제공하는 인터페이스. 사용자는 마우스, 키보드 또는 터치 스크린 등을 사용하여 그래픽으로 표시된 아이콘, 창, 버튼 등을 클릭하거나 조작하여 작업을 수행할 수 있다.
<br>
<br>

- `시스템 콜` : 운영 체제 커널이 제공하는 서비스에 대한 인터페이스를 제공하는 소프트웨어 요청. 프로그램이 운영 체제의 기능을 사용하려고 할 때, 그 프로그램은 시스템 콜을 호출하여 운영 체제에게 해당 기능을 요청한다.
    - 용도
        1. `자원 접근` : 파일 시스템, 네트워크, 디바이스 드라이버 등과 같은 시스템 자원에 접근하기 위해 사용됩니다. 예를 들어, 파일을 열거나 닫는 데 사용

        2. `프로세스 제어` : 새 프로세스를 생성하거나 종료하는 등의 프로세스 관리 작업을 수행

        3. `메모리 관리` : 메모리 할당 및 해제, 메모리 보호 등과 같은 메모리 관리 작업을 수행

        4. `프로세스간 통신` : 프로세스 간의 통신을 위해 사용될 수 있습니다. 이는 파이프, 소켓, 메시지 큐 등을 통해 이루어짐

        5. `시스템 정보의 조회 및 변경` : 운영 체제에서 제공하는 시스템 정보를 조회하거나 변경하기 위해 사용
<br>
<br>

![하드웨어구성](/이미지/스크린샷%202024-03-14%20오전%2011.23.13.png)

- `하드웨어` : 컴퓨터 시스템의 물리적인 부분으로, 전기적, 기계적, 전자적인 장치들의 집합을 의미. 하드웨어는 소프트웨어가 실행되고 데이터를 처리하는 데 필요한 모든 물리적 구성 요소를 포함한다.

    - 구성요소
        1. `CPU(중앙 처리 장치)` : 프로그램의 명령어를 해석하고 실행하는 역할을 담당. CPU는 산술 및 논리 연산을 수행하고, 프로그램의 제어 흐름을 관리한다.

        2. `메인 메모리` : 데이터와 명령어를 저장하는 장치로, CPU에 의해 빠르게 접근할 수 있다. 주 메모리로는 RAM(Random Access Memory)이 있으며, CPU가 직접 접근하여 데이터를 읽고 쓸 수 있는 주 기억 장치로, 컴퓨터의 작업 공간으로 생각할 수 있다. 메인 메모리는 컴퓨터 시스템이 실행 중인 프로그램의 코드와 데이터를 저장하는 데 사용된다. 전원이 꺼지면 데이터가 사라지는 휘발성 저장 장치이다.

        3. `입출력 장치` : 데이터를 시스템으로 입력하거나 시스템에서 출력하는 데 사용. 키보드, 마우스, 모니터, 프린터, 스캐너, 네트워크 카드 등이 이에 해당한다.

        4. `보조 기억 장치(Auxiliary Storage)` : 데이터를 영구적으로 저장하는 데 사용된다. 주로 대용량의 데이터 및 프로그램 파일을 저장하는 데 사용된다. 일반적인 보조 기억 장치로는 하드 디스크 드라이브(HDD), 솔리드 스테이트 드라이브(SSD), 광 디스크 등이 있다. 보조 기억 장치는 전원이 꺼져도 데이터가 보존되므로 영구 저장 장치로 알려져 있다.

        5. `버스(Bus)` : 하드웨어 간 데이터 및 제어 신호를 전송하는 통신 경로. CPU, 메모리, 입출력 장치 등이 이를 통해 통신한다.

        6. `시스템 보드(System Board)` : 다른 하드웨어 구성 요소들을 연결하고 지원하기 위한 메인 보드입니다. CPU 소켓, 메모리 슬롯, 확장 슬롯 등이 있다.

    - CPU 세부구성
        1. `ALU (Arithmetic Logic Unit, 산술 논리 장치)` :
        ALU는 컴퓨터의 중앙 처리 장치(CPU) 내에서 연산을 수행하는 부분이다.
        산술 연산(덧셈, 뺄셈, 곱셈, 나눗셈 등)과 논리 연산(AND, OR, NOT, XOR 등)을 수행한다.
        ALU는 레지스터에 저장된 데이터를 읽어와서 연산을 수행하며, 연산 결과를 다시 레지스터에 저장한다.
        컴퓨터의 연산 속도 및 성능은 ALU의 성능에 크게 의존한다.
        
        2. `CU (Control Unit, 제어 장치)` :
        CU는 CPU 내에서 바이너리 명령어(ex. 1110001100101)를 해석하고 실행하는 부분이다.
        명령어를 해독하여 해당하는 연산이나 데이터 전송 등을 수행하기 위해 다른 하드웨어 장치를 제어한다.
        명령어의 실행 순서를 제어하고, 연산 장치 및 메모리 간의 데이터 흐름을 조정한다.
        CU는 ALU와 메모리 간의 데이터 전송을 조정하고, 프로그램 카운터를 업데이트하여 다음 실행할 명령어의 위치를 지정한다.
        
        3. `Register Set (레지스터 세트)` :
        레지스터 세트는 CPU 내에 있는 고속 메모리로, CPU 내부에서 데이터를 일시적으로 저장하고 처리하는 데 사용된다.
        레지스터는 매우 빠른 속도로 접근할 수 있으며, CPU의 연산에 필요한 중요한 데이터를 보관한다.
        레지스터는 CPU의 일부분으로, 명령어의 실행에 필요한 데이터를 저장하거나 임시로 연산 결과를 저장한다.
        대부분의 CPU는 여러 종류의 레지스터를 포함하고 있으며, 이러한 레지스터들은 연산에 필요한 주소, 연산 결과, 연산에 필요한 데이터 등을 저장한다.

    - 메인 메모리와 보조 기억 장치의 주요 차이점
        1. 접근 속도와 용도
            - 메인 메모리 : 메인 메모리는 CPU가 직접 접근하여 데이터를 읽고 쓸 수 있는 주 기억 장치이다. 메인 메모리는 CPU와 매우 가까이 위치하며 매우 빠른 접근 속도를 가지고 있다. 프로그램이 실행될 때 필요한 데이터와 명령어가 메인 메모리에 로드되어 CPU에 의해 처리된다.

            - 보조 기억 장치 : 보조 기억 장치는 메인 메모리보다 접근 속도가 느리지만, 더 큰 저장 용량을 가지고 있다. 주로 대용량 데이터 및 프로그램 파일을 저장하는 데 사용된다. 
        
        2. 가격과 용량
            - 메인 메모리 : 메인 메모리는 비교적 작은 용량을 가지지만, 비용이 더 비싸고 접근 속도가 빠르다. 대개 몇 기가바이트에서 수십 기가바이트 정도의 용량을 가진다.

            - 보조 기억 장치 : 보조 기억 장치는 대용량의 데이터를 저장할 수 있으며, 비교적 저렴한 가격에 높은 용량을 제공한다. 수백 기가바이트에서 수 테라바이트 이상의 용량을 가질 수 있다.

        3. 지속성
            - 메인 메모리 : 전원이 꺼지면 메인 메모리에 저장된 데이터가 사라진다(휘발성). 따라서 메인 메모리는 일시적인 데이터 저장에 사용된다.

            - 보조 기억 장치 : 보조 기억 장치는 전원이 꺼져도 데이터가 유지됩니다(보존성, 영구성). 따라서 영구적인 데이터 저장에 사용된다.
<br>
<br>

- `드라이버` : 컴퓨터의 하드웨어 장치를 제어하고 관리하기 위한 소프트웨어. 운영 체제와 하드웨어 간의 통신을 중개하며, 하드웨어를 컴퓨터에서 올바르게 작동하도록 지원한다.
    - 기능
        1. `하드웨어 제어` : 드라이버는 하드웨어를 제어하고 관리. 이는 하드웨어의 동작을 초기화하고 설정하는 것을 포함한다.

        2. `운영 체제와의 통신` : 드라이버는 운영 체제와의 통신을 담당. 하드웨어의 상태를 보고하고, 운영 체제로부터 명령을 받아 하드웨어를 제어한다.

        3. `자원 할당 및 해제` : 운영 체제가 하드웨어 자원을 할당하거나 해제할 때, 이러한 작업을 처리하는 데 드라이버가 필요.

        4. `오류 처리 및 예외 처리` : 드라이버는 하드웨어에서 발생하는 오류를 감지하고 처리한다. 이는 예기치 않은 상황에 대비하여 안정성과 신뢰성을 높이는 데 도움이 된다.

## CPU의 이해
![CPU구조](/이미지/스크린샷%202024-03-14%20오전%2011.42.27.png)

ALU, CU, 레지스터 세트는 협력하여 CPU가 프로그램을 실행하고 데이터를 처리하는 데 필요한 모든 기능을 제공한다. CU는 명령어를 해석하고 제어 신호를 발생시켜 ALU 및 다른 하드웨어 구성 요소를 조정하며, ALU는 주어진 연산을 수행하고 레지스터 세트는 데이터를 저장하고 보유한다. 이러한 구성 요소들은 CPU의 동작을 조정하여 프로그램의 명령어를 실행하고 결과를 생성한다.

- ALU(산술 논리 장치)
    - 기능 : ALU는 주어진 연산을 수행한다. 예를 들어, 두 개의 숫자를 더하는 경우, ALU는 덧셈 연산을 수행하여 결과를 생성한다. 더하기, 빼기, 곱하기, 나누기와 같은 산술 연산 뿐만 아니라 논리 연산(AND, OR, NOT 등)도 수행할 수 있다.
    
- CU(제어 장치)
    - 기능 : CU는 바이너리 명령어의 해석과 실행을 담당합니다. 먼저, CU는 메모리에서 명령어를 가져와 해석다. 명령어가 무엇을 수행해야 하는지를 인식하고, 해당하는 제어 신호를 발생시켜 ALU나 메모리, 레지스터 등에 필요한 작업을 지시한다.

- 레지스터 세트(Register Set)

    - 기능 : 데이터 저장 및 임시 결과 보유한다. 레지스터는 CPU 내부에 있는 작은 저장 공간으로, 빠른 액세스 속도를 제공한다. 레지스터 세트에는 다양한 목적으로 사용되는 여러 레지스터가 포함될 수 있다. 예를 들어, 데이터를 임시로 저장하거나 연산 중에 발생한 중간 결과를 보유하는 데 사용된다.

    - 종류
        1. `프로그램 카운터(Program Counter)`
            - 기능 : 다음에 실행할 명령어의 메모리 주소를 저장하는 역할을 한다.

            - 동작 : CPU는 프로그램 카운터가 가리키는 메모리 주소에서 명령어를 가져와 실행한다. 프로그램이 실행되는 동안, 프로그램 카운터는 명령어의 실행 순서를 추적하고 다음에 실행할 명령어의 위치를 나타낸다. 명령어가 실행되면 프로그램 카운터는 다음 명령어의 주소로 업데이트되어야 한다. 프로그램의 흐름을 제어하고 다음에 실행할 명령어를 결정하는 데 중요한 역할을 한다. 

        2. `인스트럭션 레지스터(Instruction Register, IR)`
            - 기능 : 현재 실행 중인 명령어를 저장하는 데 사용된다. CPU가 메모리로부터 명령어를 가져와 해석하고 실행할 때, 해당 명령어는 인스트럭션 레지스터에 저장된다.

            - 동작 : 인스트럭션 레지스터는 CPU가 현재 실행 중인 명령어를 유지하는 역할을 다. 명령어가 실행되는 동안, 인스트럭션 레지스터는 해당 명령어의 내용을 유지하고 CPU가 명령어를 해석하고 실행하는 데 필요한 정보를 제공한다.
            일반적으로 CPU는 메모리로부터 명령어를 가져와 인스트럭션 레지스터에 로드한 후, 해당 명령어를 해석하고 실행한. 명령어의 실행이 완료되면 다음 명령어가 로드되어 인스트럭션 레지스터에 저장된다. 이와 같은 방식으로 CPU는 프로그램의 명령어를 한 번에 하나씩 순차적으로 실행한다.

        3. `어드레스 레지스터(Address Register)`
            - 기능 : 메모리 주소를 저장하는 데 사용된다. CPU가 메모리나 입출력 장치와 통신할 때, 어드레스 레지스터는 해당 장치의 주소를 저장하고 전송한다. CPU와 다른 하드웨어 장치 간의 데이터 통신에서 사용되며, 데이터의 안정적인 전송을 보장하는 데 중요한 역할을 다. 데이터를 임시로 저장하고 필요할 때 전송함으로써 시스템의 효율성과 안정성을 향상시킨다.

            - 동작 : 어드레스 레지스터는 주로 주소 계산 및 메모리 주소 지정에 사용된다. 프로세서가 메모리에서 데이터를 읽거나 쓰려면 어드레스 레지스터에 목표 메모리 주소를 로드하고 해당 주소로 데이터를 전송한다. 또한 입출력 장치와의 통신에도 사용될 수 있다.
            어드레스 레지스터는 메모리 액세스 또는 입출력 작업이 필요한 때에만 사용된다. 명령어를 실행하는 동안 CPU는 필요한 메모리 주소를 어드레스 레지스터에 로드하여 데이터를 읽거나 쓸 수 있다.

        4. `버퍼 레지스터(Buffer Register)`
            - 기능 : 데이터가 임시로 저장되는 레지스터로, 데이터를 한 곳에서 다른 곳으로 전송하는 데 사용된다. 버퍼 레지스터는 데이터를 보유하고 필요할 때 다른 장치로 전송하는 역할을 한다.

            - 동작 : 버퍼 레지스터는 입력과 출력 간의 데이터 흐름을 조절하며, 데이터를 안정적으로 전송하는 데 도움이 된다. 예를 들어, 입력 장치에서 CPU로 데이터를 전송하거나, CPU에서 출력 장치로 데이터를 보내는 경우에 사용될 수 있다.
            또한, 버퍼 레지스터는 데이터 전송 과정에서 속도 차이를 조절하는 데 사용될 수 있다. 속도가 빠른 장치와 느린 장치 간의 데이터 전송에서 버퍼 레지스터는 데이터의 흐름을 조절하여 데이터 손실이나 오류를 방지한다.

        5. `플래그 레지스터(Flag Register)`
            - 기능 : 프로세서의 상태를 나타내는 데 사용된다. 플래그 레지스터에는 연산 결과나 프로세서의 상태에 대한 여러 플래그(Flag)가 저장된다.

            - 주요 플래그
                1. `제로 플래그(Zero Flag, Z)` : 최근에 수행된 연산의 결과가 0이면 제로 플래그가 설정된다. 이 플래그는 주로 비교 연산 결과를 확인할 때 사용된다.

                2. `부호 플래그(Sign Flag, S)` : 최근에 수행된 연산의 결과가 음수이면 부호 플래그가 설정된다.

                3. `오버플로 플래그(Overflow Flag, O)` : 최근에 수행된 연산의 결과가 특정 범위를 초과하면 오버플로 플래그가 설정된다.

                4. `캐리 플래그(Carry Flag, C)` : 최근에 수행된 연산에서 발생한 캐리(자릿수 올림)가 있는 경우 캐리 플래그가 설정된다.

                5. `패러티 플래그(Parity Flag, P)` : 최근에 수행된 연산의 결과에 비트 수가 짝수이면 패러티 플래그가 설정된다.

            - 동작 : 플래그 레지스터는 프로세서의 상태를 확인하고 제어하는 데 중요한 역할을 한다. 프로그램이 실행되는 동안 플래그 레지스터의 상태를 확인하여 프로그램의 제어 흐름을 조정하거나 조건 분기를 수행할 수 있다. 특히, 비교 연산과 같은 조건부 명령어에서 플래그 레지스터의 값이 사용된다.

        6. `스택 포인터(Stack Pointer)`
            - 기능 : 프로그램이 실행되는 동안 사용되는 중요한 레지스터 중 하나입니다. 스택(Stack)은 메모리의 일부분으로, 데이터를 임시로 저장하는데 사용된다.

            - 동작 : 스택은 후입선출(Last In First Out, LIFO)의 구조를 가지고 있어 데이터가 쌓이는 방식으로 작동한다.
            스택 포인터는 현재 스택의 맨 위에 있는 데이터의 위치를 가리키는 역할을 한다. 스택은 메모리의 일부분을 차지하므로 스택 포인터는 메모리 주소를 가리키며, 스택의 최상위 데이터의 위치를 가리킨다. 스택 포인터는 스택에 데이터를 푸시(push)하거나 팝(pop)할 때 사용되며, 스택의 크기가 동적으로 변경될 때 포인터가 조정된다.
            스택 포인터는 일반적으로 메모리의 상단부에서 하향식으로 증가하는 방식으로 동작한다. 이는 새로운 데이터가 스택에 푸시될 때마다 스택 포인터가 증가하여 새 데이터의 위치를 가리키게 된다. 반대로 데이터가 스택에서 팝될 때마다 스택 포인터가 감소하여 스택의 최상위 데이터의 위치를 변경한다.
            스택 포인터는 프로그램의 실행 중에 스택에 데이터를 저장하고 검색하는 데 사용되며, 서브루틴 호출, 지역 변수 저장, 함수 호출 및 복귀 등 다양한 프로그램 작업에 활용된다. 스택 포인터는 프로그램의 실행 흐름을 제어하고 임시 데이터를 안전하게 저장하는 데 중요한 역할을 한다.

- 클럭 펄스(Clock Pulse)
    ![클럭펄스](/이미지/main-qimg-8aee230fe57a7f3b03593bc8b33874a9-lq.jpeg)

    디지털 시스템에서 주기적으로 발생하는 전압 또는 전류의 변화입니다. 클럭 펄스는 일종의 신호로, 전자 장치의 동작을 조절하고 동기화하는 데 사용된다. 

    일반적으로 클럭 펄스는 일정한 주기로 반복되는 사각파(Square Wave) 형태의 신호로 표현됩니다. 각 클럭 펄스는 시스템의 하나의 클럭 주기를 나타내며, 클럭 주기에 따라 시스템의 작업이 진행된다.

    클럭 펄스의 주기는 클럭 속도(Clock Speed) 또는 클럭 주파수(Clock Frequency)로 표현된다. 이는 1초 동안 발생하는 클럭 펄스의 횟수를 나타내며, 주로 헤르츠(Hertz, Hz) 단위로 표시된다. 클럭 속도가 높을수록 시스템은 더 많은 클럭 펄스를 처리하고 데이터를 전송할 수 있다.

    클럭 펄스는 컴퓨터 시스템의 모든 구성 요소에 의해 사용되며, CPU, 메모리, 입출력 장치 등의 동작을 동기화하여 데이터의 안정적인 전송과 처리를 보장한다. 또한 클럭 펄스는 시스템의 전원 소비를 최적화하고, 오버클럭킹(Overclocking)과 같은 작업에서 성능을 향상시키는 데에도 사용될 수 있다.

## 프로그램 실행 과정
- 기본 구조
    ![코드 과정](/이미지/스크린샷%202024-03-14%20오후%204.10.13.png)
<br>
<br>
- 실행파일의 실행 과정
    ![컴파일과정](/이미지/스크린샷%202024-03-14%20오후%204.11.31.png)
<br>
<br>
- 메모리에서 cpu로 진행되는 과정
    ![과정](/이미지/스크린샷%202024-03-14%20오후%204.13.55.png)
    
    1. Fetch : 메모리에 저장된 명령어를 cpu로 가져오기 위한 과정. 인스트럭션 레지스터를 사용한다.
        - CPU는 메모리에서 다음에 실행할 명령어를 가져오기 위해 프로그램 카운터(PC)에 저장된 주소를 사용한다.
        - 프로그램 카운터는 메모리에서 명령어의 위치를 가리키는 포인터로 사용된다.
        - CPU는 프로그램 카운터가 가리키는 주소로 이동하여 해당 명령어를 메모리에서 읽어온다.
        - 읽어온 명령어는 명령어 레지스터(IR)에 저장된다.

    2. Decode : 가져온 명령어를 해독하고 이해하는 과정, 명령어의 종류를 식별하고 필요한 데이터를 추출하는 등의 작업을 수행한다. CU가 담당하는 부분이다.
        - 가져온 명령어는 명령어 레지스터(IR)에 저장되어 있으며, CPU는 이 명령어를 해석한다.
        - 명령어는 그 종류에 따라 다른 동작을 수행해야 하기 때문에, CPU는 명령어의 종류를 식별하고 해당하는 작업을 수행할 수 있는 준비를 합니다.

    3. Execution : 해석된 명령어를 수행하는 단계이다. ALU의 담당 부분이다.
        - CPU는 명령어에 따라 필요한 작업을 수행하고, 데이터를 처리하거나 제어 흐름을 변경한다.
        - 산술 연산을 수행하거나 메모리에 데이터를 저장하는 등의 작업이 이루어진다.
<br>
<br>
- 버스 시스템을 통한 데이터 이동
    ![Bus](/이미지/스크린샷%202024-03-14%20오후%204.17.46.png)

### 폰 노이만 구조
![폰노이만](/이미지/스크린샷%202024-03-14%20오후%204.04.49.png)

폰 노이만 구조는 현대 컴퓨터 아키텍처의 중요한 출발점이며, 대부분의 일반적인 컴퓨터 시스템이 이러한 구조를 기반으로 설계되어 있다.

폰 노이만 구조(또는 폰 노이만 아키텍처)는 컴퓨터 시스템의 설계 구조 중 하나로, 프로그램과 데이터가 메모리에 저장되고, 중앙 처리 장치(CPU)가 이를 순차적으로 처리하는 방식을 나타낸다. 

- 특징
    1. `프로그램과 데이터의 분리` : 폰 노이만 구조에서는 프로그램과 데이터가 메모리에 동일한 형태로 저장된다. 이는 프로그램이 데이터와 동일한 방식으로 처리될 수 있음을 의미한다. 따라서 프로그램은 수정되지 않고도 CPU가 새로운 명령어를 실행할 수 있다.

    2. `명령어의 순차적 실행` : CPU는 메모리에 저장된 프로그램의 첫 번째 명령어부터 시작하여 순차적으로 실행된다. 각 명령어는 메모리에서 읽히고 해독되어 해당하는 작업을 수행한다. 이러한 구조는 프로그램의 흐름을 단순화하고 제어를 용이하게 한다.

    3. `명령어와 데이터의 통합된 버스` : 폰 노이만 구조에서는 명령어와 데이터가 동일한 버스를 통해 CPU와 메모리 간에 전송된다. 이는 명령어와 데이터를 읽고 쓰는 데 사용되는 인터페이스를 단순화한다.

    4. `바이너리 연산` : 폰 노이만 구조에서는 모든 명령어와 데이터가 이진수(binary) 형식으로 표현된다. 이는 컴퓨터의 기본적인 데이터 표현 방식이며, 모든 연산은 이진수로 표현되어 처리된다.


## 인터럽트(Interrupt)
`인터럽트(Interrupt)`는 CPU가 어떤 작업을 수행하고 있을 때, 작업을 방해하는 신호를 가리키는 말이다.

CPU가 현재 수행 중인 작업을 중단하고 다른 작업을 처리할 수 있도록 하는 메커니즘이다.

인터럽트가 발생하면 CPU는 현재 실행 중인 작업을 일시 중단하고 인터럽트를 처리하기 위한 인터럽트 서비스 루틴(Interrupt Service Routine, ISR)으로 제어를 이전한다. ISR은 해당 인터럽트의 원인을 처리하고, 필요한 작업을 수행한 후에는 원래 실행 중이던 작업으로 복귀한다.

인터럽트는 시스템의 효율성과 다양한 장치와의 상호 작용을 가능하게 한다.

CPU에서는 정상적으로 수행할 수 없는 명령어가 입력되면 인터럽트를 발생시키기도 하는데, 이렇게 발생하는 인터럽트를 가리켜 `동기 인터럽트`나 `예외` 라고 부르기도 한다.

입출력 장치(하드웨어)로부터 발생하는 인터럽트는 `비동기 인터럽트`라고 표현한다.

- 인터럽트 서비스 루틴(Interrupt Service Routine, ISR) or 인터럽트 핸들러
: 인터럽트를 처리하기 위해 특정 인터럽트 신호에 미리 정의되어 있는 프로그램 또는 함수이다.

1. 내부 인터럽트(Internal Interrupt): CPU 내부에서 발생하는 인터럽트로, 주로 프로그램 실행 도중에 발생하는 오류나 예외 상황에 의해 유발된다. 예를 들어, 연산 오버플로우(Overflow)나 잘못된 명령어 실행 등이 있다.

2. 외부 인터럽트(External Interrupt): 외부 장치나 외부 이벤트에 의해 발생하는 인터럽트이다. 이러한 인터럽트는 주로 입출력 장치의 작업 완료, 하드웨어 오류, 타이머 인터럽트 등에 의해 발생한다.

- 인터럽트 핸들러 실습

    [1. interrupt.py](/실습파일/1.%20interrupt.py)

    <details>
    <summary>1. interrupt.py 코드 펼쳐보기</summary>
    
    ```python
    # 인터럽트 예제

    import time
    import signal # 신호 처리 라이브러리, 비동기 인터럽트에 대한 핸들러

    # signum : 인터럽트의 유형 번호
    # frame : 메모리영역 중 스택 영역의 정보
    # 아래함수는 인터럽트 서비스 루틴, 인터럽트 핸들러의 역할

    def signal_handler(signum, frame):
        print("키보드 인터럽트 감지")
        print('신호 번호 : ', signum)
        print('스택 프레임 : ', frame)
        exit() # 무한루프를 돌리다가 인터럽트 발생시 강제종료

    # signal.SIGINT 키보드 인터럽트 상수
    signal.signal(signal.SIGINT, signal_handler)

    while True:
        print('5초 간격으로 출력중...')
        time.sleep(5)
    ```
    </details>
<br>
<br>

# 프로세스란?

실행중인 프로그램을 뜻한다. 프로그램을 실행하기 위해서 운영체제는 필요한 자원을 할당하고 관리하기 시작한다.

하나의 프로세스는 실행 중인 프로그램의 인스턴스로, 메모리에 할당된 리소스와 실행 상태를 가지고 있다.

각각의 프로세스는 독립적으로 실행되며, 다른 프로세스와는 독립된 메모리 공간을 가진다.

프로세스는 컴퓨터 시스템에서 중요한 개념으로, 다양한 응용 프로그램이 동시에 실행되고 관리될 수 있도록 한다. 

각 프로세스는 실행 중인 프로그램의 상태를 나타내며, 운영 체제에 의해 관리되어 효율적으로 리소스를 사용하고 실행된다.
<br>
<br>
## 프로세스의 구조
![프로세스 구조](/이미지/스크린샷%202024-03-15%20오전%2010.07.31.png)

- 코드영역 : 프로세스가 실행할 명령어들의 집합. 코드 세그먼트에는 프로그램의 명령어들이 메모리에 저장되어 있으며, CPU가 이를 실행한다.

- 데이터 영역 :  프로세스가 사용하는 전역 변수, 정적 변수, 상수 등이 저장된다. 이 세그먼트는 초기화된 데이터와 초기화되지 않은 데이터(BSS 세그먼트)로 나뉜다.

- 스택 영역 : 프로세스의 함수 호출 및 지역 변수를 저장하는 데 사용된다. 함수가 호출될 때마다 스택에 새로운 프레임이 생성되며, 함수가 반환될 때 이전 프레임이 제거된다. -> 휘발성 데이터

- 힙 영역 : 동적으로 할당된 메모리를 저장하는 데 사용된다. 힙은 프로세스의 실행 중에 동적으로 메모리를 할당하고 해제할 수 있으며, 주로 동적으로 생성된 객체나 데이터 구조를 저장한다.

- 레지스터 영역 : CPU 내부에 있는 작은 메모리 공간으로, 프로세스의 실행 중에 현재 실행 중인 명령어나 데이터를 일시적으로 저장하는 데 사용된다. 레지스터에는 프로그램 카운터(PC), 스택 포인터(SP), 베이스 레지스터(BP) 등이 포함된다.
<br>
<br>

### 프로세스 존재 확인 실습 코드

<details>
<summary>2. process.py - 파이썬 프로세스 할당 코드 펼쳐보기</summary>

```python
# 파이썬 프로그램도 프로세스가 될 수 있다.
# 파이썬 코드 동작시 할당되는 프로세스의 아이디를 확인하는 코드
import os

# os.getpid() -> 프로세스 아이디를 가져옴
print('파이썬 코드 실행중.. 실행중인 프로세스 아이디는 : ', os.getpid())
```
</details>

<details>
<summary>2. process.py - 크롬 프로세스 확인 펼쳐보기</summary>

```python

# 내 컴퓨터에서 돌아가는 크롬에 해당하는 프로세스 조회하기
# pip install psutil
import psutil

# 프로세스들에 반복적으로 접근하여 개별 프로세스의 이름을 가져옴
for proc in psutil.process_iter():
    process_name = proc.name()
    # 프로세스의 이름에 크롬이 포함되어있으면 프린트.
    if "chrome" in process_name:
        print(process_name, proc.pid)
```

</details>
<br>
<br>

## 프로세스 상태
![프로세스 상태 변화](/이미지/스크린샷%202024-03-15%20오전%2010.34.20.png)
```
- 생성(Created): 프로세스가 생성되었지만 아직 실행되지 않은 상태. 이 상태에서는 운영체제가 프로세스를 초기화하고 필요한 자원을 할당한다.

- 준비(Ready): 프로세스가 실행을 기다리는 상태. 준비 상태에 있는 프로세스는 CPU를 사용할 준비가 되어 있지만, 아직 CPU를 할당받지 못한 상태이다.

- 실행(Running): CPU를 사용하여 명령어를 실행하는 상태. 실행 상태에 있는 프로세스는 현재 CPU를 사용하고 있다.

- 대기(Waiting 또는 Blocked): 프로세스가 어떤 이벤트를 기다리는 상태. 예를 들어, 입출력 완료를 기다리거나, 특정 자원의 사용 허가를 기다리는 경우가 있을 수 있다.

- 종료(Terminated 또는 Exit): 프로세스가 실행을 완료하고 종료된 상태. 종료된 프로세스는 운영체제에 의해 메모리에서 해제되고 관련된 자원이 반환된다.
```

프로세스는 이러한 상태를 변경하면서 실행된다. 보통은 cpu는 하나의 프로세스만 실행가능 하기 때문에 생성 → 준비 → 실행 → 대기 → 실행 → 대기 → ... → 종료 의 순서로 상태가 변경된다.

준비 상태에서 실행 상태로 전환하기 위해서는 CPU 스케줄러에 의해 선택되어 CPU를 할당받아야 한다. 

대기 상태에서 실행 상태로 전환하기 위해서는 해당 이벤트가 발생하여 대기 상태를 벗어나야 한다.
<br>
<br>
### 프로세스 제어 블록(Process Control Block, PCB)

CPU는 한 번에 하나의 연산을 수행할 수 있기 때문에 여러 개의 프로세스를 동시에 실행하지 않고 빠르게 번갈아가면서 실행하게 된다.

이를 위해 운용체제는 PCB를 만들어서 관리하는데, 여기에는 프로세스를 식별하기 위해서 필요한 정보들이 저장된다.
ex. process ID, register data, scheduling config, status ...

PCB는 각 프로세스에 대해 운영체제가 유지하는 정보이므로, 프로세스가 생성되고 종료될 때마다 PCB가 생성되거나 삭제됩니다. PCB는 프로세스의 상태 변화에 따라 업데이트되며, 운영체제가 프로세스를 스케줄링하고 제어하는 데 필요한 핵심 데이터를 제공한다.

- PCB에 포함되는 정보
    1. `프로세스 상태(Process State)` : 프로세스의 현재 상태. 예를 들어, 실행 중인지 대기 중인지, 중단되었는지 등을 나타낸다.

    2. `프로그램 카운터(Program Counter, PC)` : 다음에 실행할 명령어의 주소를 가리키는 레지스터 값.

    3. `레지스터 상태(Register State)` : CPU 레지스터의 내용을 저장한다. 이는 프로세스가 중단되었을 때 해당 레지스터 값을 저장하고, 다시 실행될 때 해당 레지스터 값을 복원하는 데 사용된다.

    4. `스케줄링 정보(Scheduling Information)` : 프로세스가 CPU를 사용할 수 있는 우선순위, 스케줄링 알고리즘에 필요한 정보 등을 포함한다.

    5. `메모리 관리 정보(Memory Management Information)` : 프로세스가 사용하는 메모리 영역의 크기와 위치를 포함한다. 이 정보는 가상 메모리 시스템에서 중요한 역할을 한다.

    6. `입출력 상태(Input/Output State)` : 프로세스가 대기 중인 입출력 작업과 관련된 정보를 포함한다. 이 정보는 입출력 작업이 완료되면 프로세스를 깨워 다시 실행되도록 하는 데 사용된다.


### 프로세스 계층
![계층](/이미지/스크린샷%202024-03-15%20오전%2010.44.37.png)

프로세스 계층(Process Hierarchy)은 운영체제에서 프로세스 간의 부모-자식 관계를 의미한다. 

일반적으로는 부모 프로세스가 자식 프로세스를 생성하는 방식으로 계층 구조가 형성된다. 

부모-자식간의 프로세스는 각각 독립적인 영역을 가진다.

이러한 계층 구조는 다양한 운영체제에서 프로세스의 관리와 제어를 용이하게 한다.

### 프로세스 실습 코드

<details>
<summary>3. process_detail.py 코드 열어보기</summary>

```python
import psutil

for proc in psutil.process_iter() :
    process_name = proc.name()
    if "chrome" in process_name:
        # 해당 프로세스의 자식을 가져옴
        child = proc.children()
        # 프로세스이름, 상태, 부모 프로세스 모두 프린트
        print(process_name, proc.status(), proc.parent())

        # 자식프로세스가 존재하면 프린트.
        if child :
            print(f'{process_name}의 자식 프로세스 : ', child)
```

</details>

### 멀티 프로세스 운영체제

동시에 여러 개의 프로세스를 실행할 수 있는 운영체제를 의미한다. 

이러한 운영체제는 여러 개의 프로세스가 동시에 실행되고 서로 독립적으로 실행될 수 있도록 지원한다. 

각 프로세스는 각각의 메모리 공간을 할당받고, 독립적으로 실행되며, 서로 영향을 주지 않는다.

### 컨텍스트 스위칭 
![컨텍스트 스위칭](/이미지/스크린샷%202024-03-15%20오전%2011.01.47.png)

CPU가 한 프로세스에서 다른 프로세스로 전환하는 과정을 의미한다.

- 발생 시기
    1. 프로세스 스케줄링: CPU 스케줄러가 다음에 실행할 프로세스를 선택하여 CPU를 할당할 때.

    2. 인터럽트 처리: 입출력 완료, 타이머 만료 등의 이벤트가 발생하여 현재 실행 중인 프로세스를 중단하고 인터럽트 서비스 루틴이 실행될 때.

- 단계
    1. 현재 프로세스의 상태 저장: 현재 실행 중인 프로세스의 상태(레지스터 값, 프로세스 상태 등)를 해당 프로세스의 PCB에 저장한다.

    2. 다음 프로세스의 상태 로드: 다음에 실행될 프로세스의 PCB에서 상태를 읽어와 CPU 레지스터에 로드한다.

    3. 프로세스 실행: 새로운 프로세스가 실행되며, 현재 프로세스의 실행이 중단된다.
<br>
<br>

## 프로세스 생성
![프로세스 생성](/이미지/스크린샷%202024-03-15%20오전%2011.31.25.png)

프로그램 실행시, 운영체제는 코드 영역과 데이터 영역을 메인 메모리에 올리고 빈 스택과 빈 힙을 만들어 공간을 확보한다. 이는 시스템에게는 상당한 부담을 주는 일이다.

운영체제 부팅시 프로세스는 딱 한번 생성되는데 그것이 최초의 프로세스가 된다.

이후에 새로운 프로세스를 생성하는 것보다, 기존 프로세스를 복사하는 것이 더 빠르다. 따라서 모든 프로세스는 최초의 프로세스로 부터 복사된다.

이때 부모 프로세스를 복사하는 함수를 fork() 함수라고 한다.

이후에 메모리영역에 코드영역과 데이터 영역을 덮어쓰는 함수는 exec() 함수이다.

=> fork함수와 exec 함수의 반복으로 새로운 프로세스가 생성되는 것이다.

### 멀티 프로세싱 실습 코드

<details>
<summary>4. multi_processing.py - 멀티 프로세스(단일 하위 프로세스) 코드 열어보기</summary>

```python
# 같은 작업을 하는 하나의 하위 프로세스 생성
from multiprocessing import Process
import os

def func():
    print('실험용으로 만들어 본 함수')
    print('나의 프로세스 아이디: ', os.getpid())
    print('나의 부모 프로세스 아이디: ', os.getppid()) # ppid는 부모 프로세스의 아이디

if __name__ == '__main__':
    print('4.multi_processing.py 프로세스 아이디: ', os.getpid())
    child = Process(target=func).start() # target을 하위 프로세스로 만듦
```

</details>

<details>
<summary>5. multi_processing2.py - 멀티 프로세스(같은 여러개의 하위 프로세스) 코드 열어보기</summary>

```python
# 같은 작업을 하는 여러 개의 하위 프로세스 생성
from multiprocessing import Process
import os

def func():
    print('실험용으로 만들어 본 함수')
    print('나의 프로세스 아이디: ', os.getpid())
    print('나의 부모 프로세스 아이디: ', os.getppid()) # ppid는 부모 프로세스의 아이디

if __name__ == '__main__':
    print('5.multi_processing2.py 프로세스 아이디: ', os.getpid())
    # 하위 프로세스를 여러개 만들 수도 있다.(트리 구조)
    child1 = Process(target=func).start() # target을 하위 프로세스로 만듦
    child2 = Process(target=func).start() # target을 하위 프로세스로 만듦
    child3 = Process(target=func).start() # target을 하위 프로세스로 만듦
```

</details>

<details>
<summary>6. multi_processing3.py - 멀티 프로세스(다른 여러개의 하위 프로세스) 코드 열어보기</summary>

```python
# 다른 작업을 하는 여러 개의 하위 프로세스 생성
from multiprocessing import Process
import os
import time

def func1():
    print("func1 프로세스 아이디: ", os.getpid())
    print("부모 프로세스 아이디: ", os.getppid())

def func2():
    print("func2 프로세스 아이디: ", os.getpid())
    print("부모 프로세스 아이디: ", os.getppid())

def func3():
    print("func3 프로세스 아이디: ", os.getpid())
    print("부모 프로세스 아이디: ", os.getppid())

if __name__ == '__main__':
    print('6.multi_processing3.py 프로세스 아이디: ', os.getpid())
    # 각각 다른 함수를 하위 프로세스로 만든다.
    child1 = Process(target=func1).start() # func1을 하위 프로세스로 만듦
    child2 = Process(target=func2).start() # func2을 하위 프로세스로 만듦
    child3 = Process(target=func3).start() # func3을 하위 프로세스로 만듦
```

</details>

<details>
<summary>7. process_homework.py - 과제 코드 열어보기</summary>

```python
# 내 파이썬 프로그램의 이름 알아보기
# psutil을 사용해서 사용중인 프로세스 중에 
# 7. process_homework.py에 해당하는 프로세스를 찾을 경우 프린트로 출력
import os
import psutil

current_pid = os.getpid()

for proc in psutil.process_iter():
    process_id = proc.pid
    if process_id == current_pid:
        print('과제의 프로세스 이름: ', proc.name())
        print('과제의 프로세스 아이디: ', proc.pid)
        print('부모 프로세스 아이디: ', proc.ppid())
        print('부모 프로세스 이름: ', psutil.Process(proc.ppid()).name())
```

</details>
<br>
<br>

## 쓰레드(Thread)의 이해
![thread-structure](/이미지/thread_structure.png)

![프로세스-Thread](/이미지/스크린샷%202024-03-15%20오후%201.35.19.png)

쓰레드(Thread)는 프로세스 내에서 실행되는 각각의 실행 흐름을 나타낸다. 

각각의 쓰레드는 독립적으로 실행되며, 프로세스의 자원을 공유한다. 

쓰레드는 쓰레드가 하나 생성될 때마다 쓰레드를 위한 스택 영역이 추가로 생성되며, 그 이외의 코드, 데이터, 힙 영역은 공유한다.

하나의 프로세스는 여러 개의 쓰레드를 가질 수 있으며, 이러한 쓰레드들은 서로 다른 작업을 동시에 처리할 수 있다.

- 특징
    1. `경량화(Lightweight)`: 쓰레드는 프로세스 내에서 실행되기 때문에 쓰레드 간의 전환(Context Switching)이 프로세스 간의 전환보다 더 빠르다. 이는 쓰레드가 프로세스의 자원을 공유하기 때문에 프로세스 간의 문맥 교환보다 더 효율적으로 수행다.

    2. `동시성(Concurrency)`: 하나의 프로세스 내에서 여러 개의 쓰레드가 동시에 실행될 수 있다. 이는 각 쓰레드가 독립적으로 실행되기 때문에 여러 작업을 동시에 처리할 수 있다.

    3. `자원 공유(Resource Sharing)`: 쓰레드는 같은 프로세스 내에서 실행되기 때문에 프로세스의 자원(메모리, 파일 등)을 공유할 수 있다. 이를 통해 쓰레드 간에 데이터를 공유하고 통신할 수 있다.

    4. `효율성(Efficiency)`: 쓰레드를 사용하면 여러 작업을 동시에 처리할 수 있으므로 시스템 자원을 효율적으로 활용할 수 있다. 또한 쓰레드 간의 통신은 프로세스 간의 통신보다 오버헤드가 적다.

### 쓰레드 실습 코드

<details>
<summary>8.thread.py 의 실습 코드 펼쳐보기</summary>

```python
import threading
import os

def func():
    print('실험용으로 만들어 본 함수')
    print('나의 프로세스 아이디: ', os.getpid())
    print('쓰레드 아이디 : ', threading.get_native_id())

if __name__ == '__main__':
    print('기존 프로세스 아이디 : ', os.getpid())
    thread1 = threading.Thread(target=func) # target에 대한 쓰레드를 생성
    thread1.start()
```

</details>

<details>
<summary>9.thread2.py 의 실습 코드 펼쳐보기</summary>

```python
import threading
import os
import time

# 문자열 데이터를 받아 무한히 출력하는 함수
# 3초마다 문자열을 출력
def something(word):
    while True:
        print(word)
        time.sleep(3)

'''

파이썬을 실행하면 기본적으로 메인 쓰레드가 하나 생기는데, 하위 쓰레드를 만들어 별도의 쓰레드에서 something이라는 함수를 실행시킨다.

하나의 프로세스 안에서 두개의 쓰레드 (메인, 하위(데몬))을 실행시키는 구조이다.

파이썬 파일을 실행해보면 메인쓰레드의 프린터문은 1초간격으로 실행되고, 별도의 쓰레드에서 3초간격으로 다른 프린터문이 실행되는 모습을 확인할 수 있다.

'''
if __name__ == "__main__":
    print('something의 프로세스 아이디: ', os.getpid())
    thread1 = threading.Thread(target=something, args=("hello",))
    thread1.daemon = True # 데몬 쓰레드 : 메인 쓰레드가 종료되면 같이 종료되는 쓰레드 -> 활성화
    thread1.start()
    print('메인 쓰레드에서 반복문을 시작')
    while True:
        try:
            print('main thread....')
            time.sleep(1)
        except KeyboardInterrupt:
            print('메인 쓰레드 종료')
            break
```

</details>
<br>
<br>

## CPU Scheduling 의 이해

CPU 스케줄링은 여러 개의 프로세스가 CPU를 사용하기 위해 경쟁할 때, 어떤 프로세스에게 CPU를 할당할지 결정하는 작업이다.

CPU 스케줄러는 운영체제의 일부로, 효율적인 자원 관리를 위해 필요하다.

- CPU 스케줄링의 목표
    1. `공정성(Fairness)` : 모든 프로세스가 CPU 시간을 공평하게 나눠 받아야 한다. 어떤 프로세스도 오랫동안 CPU를 독점해서는 안된다.

    2. `효율성(Efficiency)` : CPU 사용률을 최대화하여 CPU를 최대한 활용해야 한다. 대기 중인 프로세스가 없는 경우 CPU가 놀지 않고 계속해서 작업을 수행해야 한다.

    3. `응답 시간(Response Time)` : 사용자의 입력에 빠르게 응답해야 한다. 응답 시간을 최소화하여 사용자 경험을 향상시켜야 한다.

    4. `턴어라운드 시간(Turnaround Time)` : 프로세스가 시스템에 도착한 시점부터 완료될 때까지 걸리는 시간을 최소화 해야 한다. 프로세스가 빠르게 완료되어야 다음 프로세스가 빠르게 실행될 수 있다.


운영체제는 프로세스의 우선순위를 고려해서 CPU 스케줄링을 하게되는데, 이를 위한 여러가지 알고리즘이 존재한다.

### CPU 스케줄링 실습 코드 ###
<details>
<summary>10. cpu_scheduling.py 실습코드 펼쳐보기</summary>

```python

'''
실행전 터미널에서 ps -el | grep python 명령어를 통해 python이라는 이름을 포함한 동작중인 프로세스의 상세내역을 출력해본다.

이후에 파이썬 파일을 실행하고 다시 명령어를 실행해보면 여러개의 프로세스가 추가되어있는 모습을 확인가능하다.

multiprocessing.spwan => 멀티 프로세스에 의해서 돌아가고있음.
multiprocessing-fork => 프로세스 복사시에 fork함수가 사용되었다.

6번째 숫자는 프로세스의 우선순위를 나타내는데 이를 통해 프로세스들의 우선순위가 모두 같은 것을 확인가능하다.

우선순위가 같은 프로세스들을 처리하기 위한 CPU 스케줄링 알고리즘이 존재한다.

'''
from multiprocessing import Process
import os

def func1():
    while True:
        try:
            print("func1 프로세스 아이디: ", os.getpid())
            print("부모 프로세스 아이디: ", os.getppid())
        except KeyboardInterrupt:
            print("KeyboardInterrupt")
            break

def func2():
    while True:
        try:
            print("func2 프로세스 아이디: ", os.getpid())
            print("부모 프로세스 아이디: ", os.getppid())
        except KeyboardInterrupt:
            print("KeyboardInterrupt")
            break

def func3():
    while True:
        try:
            print("func3 프로세스 아이디: ", os.getpid())
            print("부모 프로세스 아이디: ", os.getppid())
        except KeyboardInterrupt:
            print("KeyboardInterrupt")
            break

if __name__ == '__main__':
    print('6.multi_processing3.py 프로세스 아이디: ', os.getpid())
    # 각각 다른 함수를 하위 프로세스로 만든다.
    child1 = Process(target=func1).start() # func1을 하위 프로세스로 만듦
    child2 = Process(target=func2).start() # func2을 하위 프로세스로 만듦
    child3 = Process(target=func3).start() # func3을 하위 프로세스로 만듦
```

</details>
<br>
<br>

## 스케줄링 알고리즘(Scheduling Algorithms)
- 스케줄링 알고리즘 적용시 고려사항
    1. 부하 최소화
    2. 컴퓨팅 자원의 효율적 사용
    3. 균형잡힌 스케줄링
    4. 대기 및 응답시간 최소화

- 대표적인 CPU 스케줄링 자료구조 - Queue
    - 준비큐(Ready Queue):
        - 준비큐는 CPU를 할당받기 위해 대기 중인 프로세스들이 위치하는 큐이다.
        - CPU를 사용할 수 있는 상태인 프로세스들이 준비큐에 위치하며, CPU를 할당받을 준비가 되어 있다.
        - 준비큐의 프로세스들은 일반적으로 실행을 기다리는 상태로, CPU를 할당받으면 실행 상태로 변경된다.
        
    - 대기큐(Wait Queue):
        - 대기큐는 입출력(IO) 작업 등의 완료를 기다리는 프로세스들이 위치하는 큐이다.
        - 입출력 작업이 완료되기를 기다리는 프로세스는 CPU를 사용할 수 없으므로 대기큐로 이동하여 대기 상태가 된다.
        - 예를 들어, 파일을 읽거나 쓰는 등의 입출력 작업이 필요한 프로세스는 해당 작업이 완료될 때까지 대기큐에 머무른다.
        - 대기큐의 프로세스들은 특정 이벤트가 발생하여 대기 중인 상태로, 해당 이벤트가 발생하면 준비큐로 이동하여 CPU를 할당받을 준비가 된다.

    - Queue를 이용한 알고리즘
        1. `FCFS(First-Come, First-Served)` : FCFS 알고리즘은 가장 간단한 스케줄링 방식으로, 큐에 도착한 순서대로 작업을 처리한다. 새로운 작업은 큐의 맨 뒤에 추가되고, 가장 앞에 있는 작업이 먼저 실행된다.

        2. `SJF(Shortest Job First)` : SJF 알고리즘은 CPU가 사용 가능한 경우, 실행 시간이 가장 짧은 작업을 먼저 실행한다. 작업이 도착할 때마다 실행 시간을 추정하여 큐에 추가하고, CPU가 사용 가능하면 가장 짧은 실행 시간을 갖는 작업이 실행된다.

        3. `Round Robin` : 라운드 로빈은 각 작업에 일정한 시간 할당량을 부여하고, 할당된 시간이 지나면 다음 작업으로 넘어가는 방식이다. 작업은 큐에 추가되고, 실행 가능한 상태가 되면 할당된 시간 동안 CPU를 사용한다. 할당 시간이 지나면 다음 작업으로 넘어가며, 나중에 다시 실행될 수 있다. 여기서 할당된 시간을 '타임 슬라이스'라고 한다.

        4. `Priority Scheduling` : 우선순위 스케줄링은 각 작업에 우선순위를 부여하고, 우선순위가 높은 작업을 먼저 실행하는 방식이다. 큐에 들어온 작업은 해당 작업의 우선순위에 따라 위치가 결정된다. 이 알고리즘만 적용하는 경우 우선순위가 낮은 프로세스는 배제되어버리는 '기아' 상태에 빠질 수 있다.

        5. `Multilevel Queue` : 여러 개의 큐를 사용하여 다양한 우선순위의 프로세스를 구분하고, 각 큐에 다른 스케줄링 알고리즘을 적용하는 방식이다.

## 프로세스간 통신
프로세스는 독립적으로 실행되지만, 필요시 다른 프로세스와 데이터를 주고 받으며 통신하는 경우가 있다. 

이를 가리켜 프로세스 간 통신(Inter-Process Communication)이라 한다.

프로세스 간 통신은 다른 프로세스 간의 데이터 전송, 동기화, 통신 채널 설정 등을 포함한다.

이를 통해 여러 프로세스가 서로 작업을 조율하고 협력하여 복잡한 작업을 수행할 수 있다.

프로세스 간 통신에서 매개체가 필요한데 이를 위한 두가지 방식이 존재한다.

- 메일슬롯(메일 박스) 방식

    ![메일슬롯](/이미지/mail-slot.png)
    - 메일슬롯 방식은 간단한 메시지 교환을 위한 방법 중 하나이다.
    - 각 프로세스는 공유된 메일슬롯이나 메일박스를 생성하고, 다른 프로세스에게 메시지를 보낼 수 있다.
    - 메일슬롯에 메시지를 쓰는 프로세스는 메시지를 메일슬롯에 보내고, 메시지를 읽는 프로세스는 메일슬롯에서 메시지를 가져와서 처리한다.
    - 단방향 처리 방식이므로 서로 데이터를 주고 받기위해서는 각각 메일슬롯을 생성해야한다.
    - 이 방식은 간단하고 직관적이며, 동기화와 관련된 문제를 처리하기 쉽다.

- 파이프 방식

    ![파이프](/이미지/pipe-method.png)
    - 파이프 방식은 UNIX 및 UNIX 계열 운영체제에서 널리 사용되는 방식 중 하나이다.
    - 두 프로세스 간에 단방향 통신을 제공합니다. 한 프로세스가 데이터를 파이프에 쓰고, 다른 프로세스가 파이프에서 데이터를 읽는다.
    - 파이프는 일반적으로 부모와 자식 프로세스 간에 생성되며, 부모 프로세스가 파이프를 생성하고, 자식 프로세스가 해당 파이프를 상속받아 사용한다.
    - 파이프는 기본적으로 운영체제가 제공하는 버퍼링 메커니즘을 사용하여 데이터를 전달하므로, 데이터를 쓰는 프로세스와 읽는 프로세스 간의 동기화 문제를 처리할 필요가 없다.


- 프로세스 간 통신의 종류
    1. `파일을 통한 통신`:
    파일을 공유하여 데이터를 교환하는 것이 가능하다. 하나의 프로세스가 데이터를 파일에 씀으로써, 다른 프로세스가 해당 파일을 읽을 수 있다. 이러한 방식은 간단하고 사용하기 쉽지만, 파일에 대한 입출력이 발생하기 때문에 오버헤드가 크고 속도가 느릴 수 있다.
    
    2. `파이프(Pipe)`:
    파이프는 단방향으로 데이터를 전달하는 방법으로, 부모 프로세스와 자식 프로세스 사이에서 주로 사용된다. 부모 프로세스는 파이프를 생성하고, 이를 통해 데이터를 전달한다. 자식 프로세스는 파이프로부터 데이터를 읽는다. 파이프는 운영체제에서 제공하는 메모리 버퍼로 구현되어 있다.
    
    3. `명명된 파이프(Named Pipe 또는 FIFO)`:
    명명된 파이프는 파일 시스템에 저장되어 이름을 가지고 있어 여러 프로세스 간에 데이터를 주고받을 수 있다. 파이프와 달리 양방향 통신이 가능하며, 동일한 시스템에서 실행되는 다른 프로세스 간에도 사용할 수 있다.
    
    4. `메시지 큐(Message Queue)`:
    메시지 큐는 프로세스 간 통신을 위해 운영체제에서 제공하는 큐 형태의 통신 메커니즘이다. 프로세스는 메시지 큐에 메시지를 보내고 받을 수 있으며, 메시지는 데이터를 포함하고 있다. 메시지 큐는 선입선출(FIFO) 방식으로 동작하며, 동기화를 위한 기능도 제공할 수 있다.

    5. `공유 메모리(Shared Memory)`:
    공유 메모리는 두 개 이상의 프로세스가 메모리 공간을 공유하여 데이터를 교환하는 방법이다. 프로세스들은 공유 메모리에 직접 접근하여 데이터를 읽고 쓸 수 있다. 공유 메모리를 사용하면 데이터를 복사하지 않고 직접 메모리에 접근하여 효율적인 통신이 가능하다.

### 프로세스 간 통신 실습 코드
<details>
<summary>11. IPC.py 실습코드 펼쳐보기</summary>

```python
from multiprocessing import Process, Pipe
import os

def send(conn):
    print(f'{os.getpid()}가 {os.getppid()}에게 데이터를 보낸다')
    conn.send('Hello parent')
    conn.close()

if __name__ == '__main__':
    parent, child = Pipe() # Pipe는 두개의 값을 반환하는 튜플 생성자이다.
    p = Process(target=send, args=(child,)) # child가 parent에 보낼것임으로 args에 child를 입력
    p.start() # 프로세스실행
    print('기존 프로세스 아이디: ', os.getpid()) 
    print(parent.recv()) # 부모가 받은것을 보여줌
    p.join() # 프로세스를 기다림
```
</details>

<details>
<summary>11. IPC.py 실습코드 펼쳐보기</summary>

```python
from multiprocessing import Process
import os
import time

# 파일을 통한 통신 예제

def wrirer():
    print(f'{os.getpid()}가 파일에 쓴다')
    with open('IPS.txt', 'w') as f:
        f.write(f'Hello')

def reader():
    with open('IPS.txt', 'r') as f:
        print(f.read())

if __name__ == '__main__':
    p1 = Process(target=wrirer)
    p1.start()

    time.sleep(2) # 파일을 쓰는동안 읽지않도록 딜레이를 준다.

    p2 = Process(target=reader)
    p2.start()

    p1.join()
    p2.join()
```
</details>
<br>
<br>

## 프로세스 동기화
프로세스 동기화는 멀티프로세스 환경에서 여러 프로세스가 공유 데이터 또는 자원에 접근할 때 발생할 수 있는 문제를 해결하는 메커니즘이다. 

프로세스 동기화의 목적은 데이터 일관성을 유지하고 경쟁 조건(race condition)과 교착상태(deadlock) 등의 문제를 피하기 위함이다.

- 프로세스 동기화 이해를 위한 개념

    1. 공유자원이란?

        프로세스가 공동으로 이용하는 파일, 입출력 기기 등

    2. 임계구역이란?

        공유자원은 각 프로세스의 접근 순서에 따라 결과가 달라질 수 있는데, 프로세스가 동시에 실행할 경우 문제가 발생할 수 있는 영역을 가리켜 '임계구역' 이라 한다.

    3. 상호배제 (Mutual Exclusion)

        상호배제는 하나의 프로세스가 공유 자원을 사용하는 동안 다른 프로세스들은 접근할 수 없도록 하는 것을 의미한다. 즉, 한 프로세스가 공유 자원에 접근 중일 때 다른 프로세스들은 대기하게 된다. 상호배제를 통해 여러 프로세스가 동시에 공유 자원에 접근하는 것을 방지할 수 있다.
        => 하나의 프로세스가 임계구역에 들어갔다면 다른 프로세스는 임계구역에 들어갈 수 없는 조건.

    4. 동기화 기법

        동기화 기법은 상호배제를 구현하는 방법으로, 공유 자원에 대한 접근을 조절하는 메커니즘이다. 대표적인 동기화 기법으로는 세마포어, 뮤텍스, 조건변수 등이 있다.

        - 세마포어 (Semaphore)
            ![세마포어](/이미지/Binary-semaphore.jpg)'

            세마포어는 상호배제를 위한 동기화 기법 중 하나로, 정수형 변수와 이를 조작하기 위한 연산들로 구성된다. 세마포어는 P(감소)와 V(증가) 연산을 제공하여 공유 자원에 대한 접근을 조절한다.

            임계구역에 여러개의 공유자원이 존재할 때, 접근이 가능한 공유자원이 없으면 기다리라는 함수를 호출 -> wait() 함수

            임계구역에 접근가능한 자원이 존재하면, 프로세스에게 이를 알려주는 함수를 호출 -> signal() 함수

        - 뮤텍스 (Mutex)
            ![뮤텍스](/이미지/mutex-locks.webp)

            뮤텍스는 상호배제를 위한 동기화 기법 중 하나로, 잠금(lock)과 해제(unlock) 연산을 통해 공유 자원에 대한 접근을 제어한다. 한 번에 하나의 프로세스만 뮤텍스를 획득할 수 있다.

            임계구역에 진입한 프로세스가 뮤텍스 락을 이용해 임계구역의 문을 잠그면 다른 프로세스들은 접근할 수 없다. -> ecquire() 함수

            임계구역에서 프로세스가 벗어날 때는 해제연산을 통해 문을 열 수 있다. -> release() 함수

        - 조건변수 (Condition Variable)

            조건변수는 프로세스들 간의 통신과 대기를 조절하기 위한 동기화 기법이다. 특정 조건이 충족될 때까지 대기하고, 다른 프로세스가 해당 조건을 만족시킬 때까지 대기한다.

### 프로세스 동기화 실습 코드
<details>
<summary>13. sync_error.py 코드 펼쳐보기</summary>

```python
from multiprocessing import Process, Value

'''
공유 숫자를 두개의 프로세스로 접근하여 하나의 프로세스는 더하기연산을 반복, 하나의 프로세스는 빼기 연산을 반복하여
뮤텍스 락을 안할경우 어떤 결과가 생기는지를 확인해보자.
'''
def counter1(snum, cnt):
    for i in range(cnt):
        snum.value += 1

def counter2(snum, cnt):
    for i in range(cnt):
        snum.value -= 1

if __name__ == '__main__':
    shared_number = Value('i', 0)
    p1 = Process(target=counter1, args=(shared_number, 5000))
    p1.start()
    p2 = Process(target=counter2, args=(shared_number, 5000))
    p2.start()

    p1.join()
    p2.join()

    print('finally, number is ', shared_number.value)
```

</details>

<details>
<summary></summary>

```python
from multiprocessing import Process, Value, Lock

'''
공유 숫자를 두개의 프로세스로 접근하여 하나의 프로세스는 더하기연산을 반복, 하나의 프로세스는 빼기 연산을 반복하여
뮤텍스 락을 적용시켜서 결과를 확인해보자
'''
def counter1(snum, cnt, lock):
    lock.acquire()
    try:
        for i in range(cnt):
            snum.value += 1
    finally:
        lock.release()

def counter2(snum, cnt, lock):
    lock.acquire()
    try:
        for i in range(cnt):
            snum.value -= 1
    finally:
        lock.release()

if __name__ == '__main__':
    lock = Lock()

    shared_number = Value('i', 0)
    p1 = Process(target=counter1, args=(shared_number, 5000, lock))
    p1.start()
    p2 = Process(target=counter2, args=(shared_number, 5000, lock))
    p2.start()

    p1.join()
    p2.join()

    print('finally, number is ', shared_number.value)
```

</details>

<details>
<summary>15.thread_sync.py 코드 펼쳐보기</summary>

```python
import threading
from multiprocessing import Value, Lock
'''
프로세스와 마찬가지로 하위 쓰레드에서도 공유자원 접근에대한 동기화를 적용해 볼 수 있다.
공유 숫자를 두개의 프로세스로 접근하여 하나의 프로세스는 더하기연산을 반복, 하나의 프로세스는 빼기 연산을 반복하여
뮤텍스 락을 적용시켜서 결과를 확인해보자
'''
def counter1(snum, cnt, lock):
    lock.acquire()
    try:
        for i in range(cnt):
            snum.value += 1
    finally:
        lock.release()

def counter2(snum, cnt, lock):
    lock.acquire()
    try:
        for i in range(cnt):
            snum.value -= 1
    finally:
        lock.release()

if __name__ == '__main__':
    lock = Lock()

    shared_number = Value('i', 0)
    t1 = threading.Thread(target=counter1, args=(shared_number, 5000, lock))
    t1.start()
    t2 = threading.Thread(target=counter2, args=(shared_number, 5000, lock))
    t2.start()

    t1.join()
    t2.join()

    print('finally, number is ', shared_number.value)
```
</details>
<br>
<br>

## 데드락(DeadLock)
멀티프로세스나 멀티스레드 환경에서 발생하는 중대한 문제 중 하나이다. 

데드락은 두 개 이상의 프로세스나 스레드가 서로가 가진 자원을 점유하고 있으면서 다른 프로세스나 스레드가 가진 자원을 기다리는 상태에서 발생한다. 

이로 인해 모든 관련 프로세스나 스레드가 무한정 대기하게 되며, 시스템이 더 이상 진행되지 못하게 된다.

- 데드락의 발생 조건
    - `상호배제 (Mutual Exclusion)`: 자원은 한 번에 하나의 프로세스나 스레드만 사용할 수 있어야 한다.
    - `보유 및 대기 (Hold and Wait)`: 프로세스나 스레드가 공유 자원을 가지고 있으면 다른 프로세스는 자원을 기다리고 있어야 한다.
    - `비선점 (No Preemption)`: 다른 프로세스나 스레드가 이미 점유한 자원을 강제로 빼앗을 수 없어야 한다.
    - `순환 대기 (Circular Wait)`: 여러 프로세스나 스레드 간에 순환 형태로 자원을 요청해야 한다.

### 과제 - 식사하는 철학자
<details>
<summary>과제 내용 펼쳐보기</summary>

```

식사하는 철학자(Philosophers Dining Problem)는 컴퓨터 과학에서 고전적인 동기화 문제 중 하나이다. 

이 문제는 다섯 명의 철학자와 다섯 개의 젓가락으로 구성된 테이블을 상상한다. 

각 철학자는 생각을 하거나 식사를 하려고 한다. 그러나 젓가락은 한 번에 한 사람만 사용할 수 있다.

# 식사하는 철학자 문제의 조건

1. 각 철학자는 생각을 할 때는 젓가락을 사용하지 않으며, 식사할 때만 사용합니다.
=> 프로세스가 대기상태일 때는 공유자원을 사용하지않고, 동작할 때 사용한다..?

2. 젓가락은 두 개가 필요한데, 각 철학자의 좌우에 하나씩 있습니다.
=> 각각의 프로세스에 대해 공유자원이 2개가 필요하다.
=> 각각의 자원은 2개의 프로세스나, 쓰레드가 공유한다.

3. 철학자는 양손에 젓가락이 모두 있을 때에만 식사를 할 수 있습니다.
=> 두개의 공유자원이 충족되어야만 동작할 수 있다.

4. 식사를 마친 후에는 젓가락을 테이블에 놓습니다.
=> 동작이 끝난 후에는 공유자원을 해제해준다.

이 문제는 다중 스레드 환경에서 공유 자원에 대한 접근을 동기화하는 방법을 찾는 문제로 해석될 수 있다. 

이를 해결하기 위해서는 상호배제와 교착상태를 피하기 위한 조치가 필요하다.

# 식사하는 철학자 문제의 해결 방법

- 호위자(Chaperone): 한 명의 철학자가 식사할 때 다른 철학자들이 젓가락을 사용하지 못하도록 막아주는 방법이다. 이 방법은 상호배제를 유지하면서 교착상태를 피할 수 있다.

- 젓가락 번갈아 놓기: 철학자가 식사를 시작하기 전에 양쪽 젓가락을 동시에 집는 것 대신에, 하나씩 집게 하나를 집어 식사를 시작한다. 이렇게 함으로써 교착상태를 피할 수 있다.

- 타임아웃 사용: 철학자가 한 젓가락을 집은 후에 일정 시간이 지나도록 다른 젓가락을 집지 못하는 경우, 젓가락을 내려놓고 다시 생각을 하는 방식이다.

# 동기화로 보는 해결방법
1. 세마포어 (Semaphore):
철학자들은 세마포어를 통해 젓가락을 요청하고, 세마포어의 값에 따라 젓가락을 획득하거나 대기한다. 각 철학자는 젓가락을 요청하기 전에 세마포어를 획득하고, 식사를 마치면 세마포어를 해제한다. 이를 통해 상호배제와 젓가락 대기를 효과적으로 관리할 수 있다.

2.뮤텍스 (Mutex):
각 젓가락은 뮤텍스로 표현될 수 있다. 철학자가 젓가락을 집을 때 해당 뮤텍스를 잠그고, 식사를 마칠 때 뮤텍스를 해제한다. 이
를 통해 각 젓가락은 한 번에 하나의 철학자만이 사용할 수 있으므로 상호배제가 유지된다.

3.조건변수 (Condition Variable):
각 젓가락은 조건변수로 표현될 수 있다. 철학자가 젓가락을 집을 때 다른 젓가락이 사용 중이라면 해당 젓가락의 조건변수를 기다리고 대기한다. 다른 철학자가 젓가락을 내려놓을 때마다 해당 젓가락의 조건변수를 시그널하여 대기 중인 철학자에게 알려준다.

이러한 방식들을 통해 젓가락을 획득하고 반납하는 과정을 동기화하여 데드락을 방지하고, 모든 철학자가 식사를 할 수 있도록 보장할 수 있다.

```

</details>

## 메모리의 이해
![메모리계층](/이미지/메모리계층구조.png)

메모리 계층은 컴퓨터 시스템에서 데이터 및 명령어를 저장하는 데 사용되는 여러 레벨의 메모리를 일컫는다. 

메모리 계층은 보다 빠르고 작고 비싼 메모리와 느리고 크고 저렴한 메모리를 조합하여 데이터 및 명령어에 대한 효율적인 접근을 가능하게 한다. 

전형적으로 사용되는 메모리 계층은 다음과 같다.

1. `레지스터(Register)`:
CPU 내부에 위치하며, 가장 빠르고 비용이 가장 비싼 메모리이다. 레지스터는 CPU가 직접 접근하여 데이터를 읽고 쓸 수 있는 고속 메모리이다. 주로 명령어 실행 중에 연산에 필요한 데이터나 중간 결과를 저장한다.

2. `캐시(Cache)`:
CPU와 주 메모리 사이에 위치하며, 레지스터와 주 메모리 사이의 중간 저장소 역할을 한다. 캐시는 주로 CPU가 자주 사용하는 데이터나 명령어를 저장하여 빠른 액세스를 가능하게 한다. 캐시는 일반적으로 L1, L2, L3와 같이 여러 레벨로 구성되어 있으며, 각 레벨의 캐시는 크기가 작으면서 더 빠르지만, 레벨이 내려갈수록 크기는 커지고 속도는 낮아진다.

3. `주 메모리(Main Memory 또는 RAM)`:
프로그램 및 데이터를 저장하는 주요 메모리이다. 주 메모리는 CPU의 레지스터와 캐시보다는 느리지만, 크기가 크고 상대적으로 저렴하다. 프로그램이 실행될 때 필요한 데이터와 명령어가 주 메모리에 적재되어 CPU에 의해 액세스된다.

4. `보조 저장장치(Secondary Storage)`:
하드 디스크 드라이브(HDD), SSD 등의 장치로 이루어진 보조 저장장치는 주 메모리와는 달리 데이터를 장기간 보존하는 데 사용된다. 주로 프로그램, 파일 및 데이터베이스 등이 저장된다. 보조 저장장치는 주 메모리보다는 느리지만, 대용량 데이터를 저장할 수 있고, 전원이 꺼져도 데이터가 보존된다.

레지스터, 캐시, 주 메모리의 영역은 휘발성 데이터이다. 반면 보조 저장장치의 데이터는 비휘발성이다.

- 메모리 다중 분할 할당 기법

    여러개의 프로세스를 메모리에 올려야 한다면, 두가지 방식을 사용할 수 있다. 가변 분할방식과 고정 분할 방식이다.

    다중 분할 할당 기법을 알아보기 전에 다음 용어들에 대해서 먼저 알아보자.

    - 스와핑:
        ![스와핑](/이미지/스크린샷%202024-03-19%20오전%2010.36.54.png)

        운영체제에서 사용되는 메모리 관리 기술 중 하나로, 주 메모리(RAM)와 보조 저장장치(하드 디스크 등) 사이에서 프로세스의 전체 또는 일부를 이동하는 것을 의미한다. 스와핑은 주 메모리의 공간이 부족한 경우나 프로세스의 우선순위에 따라 메모리를 재배치할 때 사용된다.
        
        - 스와핑 과정
            1. 스왑 아웃(Swap Out): 실행 상태가 아닌 주 메모리에 올라와 있는 프로세스나 페이지 중 일부가 보조 저장장치로 이동된다. 이는 주 메모리의 공간을 확보하기 위한 것이다.

            2. 스왑 인(Swap In): 필요한 경우, 실행하여야 하는 보조 저장장치에 있는 프로세스나 페이지를 주 메모리로 다시 가져온다. 이는 프로세스가 다시 실행될 때 필요한 데이터나 명령어에 접근하기 위함이다.

        - 스와핑이 발생하는 상황
            1. 메모리 부족(Memory Overcommitment): 주 메모리에 사용 가능한 공간이 부족한 경우, 운영체제는 사용되지 않는 프로세스나 페이지를 보조 저장장치로 스왑아웃하여 공간을 확보한다.
            
            2. 프로세스 우선순위 변경(Priority-Based Swapping): 운영체제는 시스템에 의해 우선순위가 낮은 프로세스의 페이지를 스왑아웃하여 우선순위가 높은 프로세스에게 공간을 양보하는 경우가 있다.
    
    - 외부 단편화:
        분할 된 영역이 할당될 프로그램보다 작아서 프로그램이 할당될 수 없어 사용되지 않고 빈 공간으로 남아있는 분할된 전체 영역
    
    - 내부 단편화:
        분할된 영역이 할당될 프로그램보다 커서 프로그램이 할당된 후 사용되지 않고 남아 있는 빈 공간

    1. 고정 분할 방식(정적 할당 기법, 페이징 기법)
        ![고정분할](/이미지/스크린샷%202024-03-19%20오전%2010.24.26.png)

        운영체제가 주기억 장치의 사용자 영역을 여러 개의 고정된 크기로 분할하고 준비상태 큐에서 준비 중인 프로그램을 각 영역에 할당하여 수행하는 기법이다.

        - 프로그램 전체가 주기억 장치에 위치해야 한다.
        - 프로그램의 크기는 다양한데 고정된 크기로 나누다보니 외부단편화나 내부단편화가 일어나 낭비되는 영역이 많다.
        - 프로그램의 크기를 미리 알고 있어야 한다.
        - 다중 프로그래밍을 위해 사용되었으나 지금은 사용하지 않는다.

    2. 가변 분할 방식(동적 할당 기법)
        ![가변분할](/이미지/스크린샷%202024-03-19%20오전%2010.24.09.png)

        단편화를 줄이기 위한 것으로 프로그램을 주기억 장치에 적재하면서 필요한 만큼의 크기로 영역을 분할하는 기법이다.

        - 주기억장치를 효율적으로 사용할 수 있고 다중 프로그래밍 정도를 높일 수 있다.
        - 프로세스 크기의 제약이 적다.
        - 영역과 영역 사이의 단편화가 발생할 수 있다.

### 메모리의 이해 실습 코드
<details>
<summary>16.memory_manage.py</summary>

```python
# 문자열 객체를 변수 my_name이 참조한다.
# 'meoyong' 이라는 문자열에대해서
# 레퍼런스 카운터가 1인 상태.
my_name = 'meoyong'

# 레퍼런스 카운터가 2인 상태
your_name = my_name

# 레퍼런스 카운터가 0 인상태
my_name = 1
your_name = 2

# 파이썬 인터프리터는 레퍼런스 카운터가 0이 되는 대상에 대해서 삭제할 것을 명령하는데
# 이런 기능을 '가비지 컬렉터'라고 한다.
```

</details>


<details>
<summary>17.memory_manage.js</summary>

```javascript
// players가 참조하는 객체 하나, boys를 참조하는 객체 하나
let players = {
    boys :{
        Bergkamp : "Striker"
    }
}

// 마찬가지로 객체하나를 참조하는데, 그 객체가 boys를 참조함
let persons = players

// 전혀다른 대상을 가리키게됨
players = ["son", "park"]

// 이 변수가 boys 객체를 직접적으로 참조함
let human = persons.boys

// persons도 전혀다른 객체를 참조함, boys객체를 참조하던 객체의 레퍼런스 카운터가 0 이됨
persons = "persons"

// human은 null이므로 boys를 참조하는 변수들이 없음 -> 레퍼런스 카운터가 0이됨
human = null
```

</details>
<br>
<br>

## 가상 메모리의 이해
가상 메모리(Virtual Memory)는 컴퓨터 시스템에서 사용되는 주 메모리(RAM)의 크기를 확장하는 기술이다. 

가상 메모리를 사용하면 주 메모리보다 큰 프로그램이나 데이터를 실행할 수 있다. 

주 메모리에 올라와 있는 프로세스의 일부 또는 전체가 보조 저장장치(하드 디스크 등)로 스왑아웃되어 필요할 때 다시 주 메모리로 가져와지게 된다.

- 페이징 기법
    ![페이징](/이미지/스크린샷%202024-03-19%20오전%2011.16.04.png)

    페이징은 가상 메모리를 관리하는 방법 중 하나로, 가상 주소 공간과 물리 메모리를 일정한 크기의 페이지로 분할하여 관리한다.
    이러한 페이지는 주 메모리와 보조 저장장치(하드 디스크 등) 사이에서 스왑될 수 있다. 
    프로세스의 페이지 중 일부만이 실제로 주 메모리에 적재되고, 나머지는 보조 저장장치에 저장된다.

    페이징 기법을 통한 가상메모리 관리를 이해하려면 물리 주소 공간과 가상 주소 공간에 대한 이해가 필요하다.
    
    운영체제는 가상메모리를 위해 가상 주소 공간과 물리 주소 공간을 일정한 크기의 공간으로 나누어 다룬다.
    이때, 가상 주소 공간의 조각은 페이지라고 불리고, 물리 주소 공간의 조각은 프레임이라 불리운다.

    - 가상 주소 공간(Virtual Address Space):
        각 프로세스는 자신만의 가상 주소 공간을 가지며, 이는 프로그램이 주 메모리에 로드되어 있는 것처럼 동작한다. 가상 주소 공간은 일반적으로 물리 메모리 크기보다 크고, 프로세스가 필요로 하는 메모리 공간 전체를 포함한다.

    - 물리 주소 공간(Physical Address Space): 
        컴퓨터의 실제 물리적인 메모리 주소를 나타낸다. 즉, 컴퓨터의 실제 하드웨어에 할당된 주소 공간을 의미한다. 각각의 메모리 셀은 고유한 물리적인 주소를 가지며, 이러한 주소들을 모아놓은 공간이 물리 주소 공간이다.

    - 페이지 테이블(Page Table):
        페이지 테이블은 가상 주소 공간의 각 페이지가 실제 물리 메모리의 어느 위치에 매핑되는지를 기록하는 테이블이다. 페이지 테이블을 통해 운영체제는 가상 주소를 물리 주소로 변환하여 페이지를 실제 메모리에 매핑한다.

        - 페이지 테이블 엔트리
            ![엔트리](/이미지/스크린샷%202024-03-19%20오전%2011.25.10.png)

            - 접근비트: 페이지가 메모리에 올라온 후 데이터에 접근이 있었는지
            - 변경비트: 페이지가 메모리에 올라온 후 데이터의 변경이 있었는지
            - 유효비트: 페이지가 어디에 있는지
            - 보호비트: 페이지에 대한 읽기, 쓰기, 실행 권한이 어떻게 되는지

        - 페이지드 세그멘테이션
            ![paged segmentation](/이미지/스크린샷%202024-03-19%20오전%2011.30.53.png)
            
            페이지드 세그멘테이션은 페이징과 세그멘테이션을 조합한 메모리 관리 기법이다. 이 방식은 세그멘테이션을 통해 프로세스를 논리적인 단위로 분할하고, 각 세그먼트를 페이지로 나누어 실제 메모리에 매핑한다. 이렇게 하면 가상 메모리와 주 메모리 사이의 매핑을 효율적으로 수행할 수 있으며, 내부 단편화와 외부 단편화를 줄일 수 있다.

    - 페이지 폴트(Page Fault):
        페이지 폴트는 프로세스가 요청한 페이지가 현재 주 메모리에 없는 경우 발생한다. 이때 운영체제는 필요한 페이지를 보조 저장장치에서 주 메모리로 가져와야 하므로, 페이지 폴트가 발생하면 해당 페이지를 주 메모리로 로드한다.

### 가상 메모리의 이해 실습코드
<details>
<summary>17.virtual_memory.py</summary>

```python
foods = ["bugger", "pizza", "salad"]

print(id(foods)) # id는 foods가 참조하는 메모리 주소(가상 주소)를 나타내준다.
print(hex(id(foods))) # id를 16 진수로 확인, 가상 주소는 실행할 때마다 바뀌는 것을 확인가능하다.

mv = memoryview(b"hello") # menoryview는 인자의 참조하는 주소를 가져온다. 인자는 이진데이터로 넣어준다.
print(mv)

# 이진데이터로 들어간 인자를 인덱싱해서 값을 가져올수도있다. 바이트형태로 전달했기 때문에 유니코드로 출력된다.
# 범위를 넘어가면 인덱스 에러를 발생시킨다.
print(mv[0])
print(mv[1])
print(mv[2])
```

</details>

<details>
<summary>19.memory_used.py</summary>

```python
import psutil
import os

print('메모리 사용량 조회하기')

# 시스템 메모리의 사용량을 튜플형태로 반환해주는데 이를 dict로 반환하게끔 만들어준다.
memory_dict = dict(psutil.virtual_memory()._asdict()) 

print(memory_dict)

total = memory_dict['total'] # 사용 가능한 총량
available = memory_dict['available'] # 즉시 제공 가능한 양
percent = memory_dict['percent'] # available을 제외한 비율

print(f'메모리 총량: {total}')
print(f'메모리 즉시 제공 가능량: {available}')
print(f'메모리 사용률: {percent}')

"""
현재 프로세스에서 사용한 메모리 조회해보기
"""
pid = os.getpid()
current_process = psutil.Process(pid)

# memory_info 가 반환한 이터레이터중 첫번째에는 프로세스가 사용한 물리적인 데이터 량이 들어있다.
# 이를 2의 20 승으로 나누면 kb로 출력이 가능하다.
kb = current_process.memory_info()[0] / 2 ** 20
print(f'메모리 사용량: {kb:.2f} kb')
```

</details>

<details>
<summary>20.tracemalloc.py</summary>

```python
import tracemalloc # 메모리 할당을 추적할 수 있도록 도와주는 라이브러리

tracemalloc.start()

# 메모리 할당이 진행되는 작업
# 1부터 10000까지 나오는 숫자를 문자열형태로 뿌리는 형태
data = [b'%d' % num for num in range(1, 10001)]
# 중간중간 공백을 넣어줌
joined_data = b' '.join(data)

current, peak = tracemalloc.get_traced_memory() # 현재 메모리사용량과 최대 메모리 사용량을 튜플로 반환해준다.
print(f'현재 메모리 사용량: {current / 10 ** 6} MB')
print(f'최대 메모리 사용량: {peak / 10 ** 6} MB')

tracemalloc.stop()

traced = tracemalloc.get_tracemalloc_memory() # tracemalloc이 사용한 메모리 조회
print(f'{traced / 10 ** 6} MB')
```

</details>

## 페이지 교체
CPU가 특정 페이지에 접근하는 명령어를 실행했을 때, 해당 페이지가 스왑 영역에 있어서 당장 실행시킬 수 없는 상태일 경우에는 '페이지 폴트' 예외가 발생한다.

페이지 폴트 예외가 발생하면 스와핑 작업이 먼저 진행된 후에 프로세스가 실행된다.

- 요구 페이징 : 실행할 모든 프로세스를 메모리에 올려두는 것은 시스템에 부담이 될 수 있는 만큼, 당장 필요한 페이지만을 메모리에 우선 적재하는 방법이다.

- 페이지 교체 정책

    가상 메모리 관리에서 사용되는 알고리즘으로, 주 메모리에 적재된 페이지 중에서 어떤 페이지를 스왑아웃하여 새로운 페이지를 적재할지를 결정하는 규칙이다. 페이지 교체 정책은 주로 가상 메모리의 효율성과 성능을 향상시키기 위해 사용된다.

    - 대표적인 정책
        1. FIFO(First-In, First-Out)

            FIFO 페이지 교체 정책은 가장 오래된 페이지를 스왑아웃하는 방식이다. 즉, 가장 먼저 주 메모리에 적재된 페이지를 스왑아웃한다. 이 방식은 구현이 간단하고 공정한 성격을 가지고 있지만, 오래된 페이지가 자주 사용되는 경우에는 페이지 폴트가 자주 발생할 수 있다.

        2. LRU(Least Recently Used)

            LRU 페이지 교체 정책은 최근에 가장 오랫동안 참조되지 않은 페이지를 스왑아웃하는 방식이다. 이 방식은 페이지가 얼마나 자주 사용되었는지를 추적하고, 가장 오랫동안 참조되지 않은 페이지를 스왑아웃한다. LRU는 이론적으로 최적의 성능을 제공하지만, 구현이 복잡하고 실제로 추적해야 할 정보가 많아질수록 성능 저하가 발생할 수 있다.

        3. LFU(Least Frequently Used)

            LFU 페이지 교체 정책은 가장 적게 참조된 페이지를 스왑아웃하는 방식이다. 이 방식은 각 페이지가 얼마나 자주 참조되었는지를 추적하고, 가장 적게 참조된 페이지를 스왑아웃한다. LFU는 최근에 자주 사용되었지만 더 이상 필요하지 않은 페이지를 스왑아웃할 때 효과적일 수 있지만, 페이지의 사용 빈도를 추적하는 데 추가적인 오버헤드가 발생할 수 있다.

        4. Clock 또는 Second Chance

            Clock 페이지 교체 정책은 FIFO와 LRU의 중간 방식으로, 시계 알고리즘을 기반으로 한다. 이 알고리즘은 페이지가 주 메모리에 적재된 시간을 기록하고, 페이지가 참조될 때마다 이 시간을 갱신한다. 페이지 교체가 필요한 경우, 시계 방향으로 페이지를 순회하면서 참조 비트를 검사하고, 참조 비트가 0인 페이지를 스왑아웃한다.
<br>    
<br>    

## 쓰레싱(thrashing)
쓰레싱(Thrashing)은 컴퓨터 시스템에서 발생하는 현상으로, 주 메모리에 너무 많은 페이지 폴트가 발생하여 시스템의 성능이 급격히 저하되는 현상을 말한다. 쓰레싱은 주로 다음과 같은 상황에서 발생한다.

1. 과도한 페이지 부재(Excessive Page Faults):

    쓰레싱은 주로 메모리에 적재된 페이지 수가 너무 적어서 주 메모리에 필요한 데이터와 명령어가 부족한 경우에 발생한다. 이로 인해 프로세스는 필요한 데이터를 주 메모리에서 찾지 못하고 보조 저장장치로부터 반복적으로 페이지를 스왑아웃하고 스왑인하는 과정을 거치게 되며, 이에 따라 페이지 폴트가 급증한다.

2. 과도한 프로세스 수행(Overloaded CPU):

    CPU가 과도하게 바쁜 경우에도 쓰레싱이 발생할 수 있다. CPU가 너무 바쁜 경우에는 페이지 폴트를 처리하기 위한 시간이 부족하여 프로세스가 메모리에 필요한 데이터에 접근하는데 필요한 시간이 부족해질 수 있다.
<br>
<br>

쓰레싱이 발생하면 시스템의 성능이 급격히 저하되며, 프로세스의 응답 시간이 길어지거나 시스템이 거의 먹통이 될 수 있다. 쓰레싱을 방지하거나 감소시키기 위해서는 다음과 같은 조치를 취할 수 있다.

1. 적절한 메모리 관리:

    메모리를 적절히 할당하고 관리하여 쓰레싱을 방지합니다. 메모리를 효율적으로 사용하여 프로세스들이 필요로 하는 데이터와 명령어를 적재할 수 있도록 합니다.

2. 우선순위 조절:

    CPU가 과도하게 바쁜 경우에는 우선순위를 조절하여 중요한 프로세스에게 CPU 자원을 할당합니다. 이를 통해 페이지 폴트를 처리하는 데 필요한 시간을 확보하여 쓰레싱을 방지합니다.

3. 스와핑 제한:

    스와핑을 제한하거나 최소화하여 쓰레싱을 방지합니다. 스와핑은 페이지 폴트를 처리하는 데 시간이 오래 걸리므로, 스와핑이 과도하게 발생할 경우 쓰레싱이 발생할 수 있습니다.

### 일일과제 - 쓰레싱 해결방법(working set) 조사하기
<details>
<summary>working set - 펼쳐보기</summary>

## 워킹셋(Working Set)
특정 프로세스가 실행 중일 때 해당 프로세스가 주 메모리에 유지해야 하는 모든 페이지의 집합을 의미한다. 이는 프로세스가 정상적으로 실행될 때 필요로 하는 모든 데이터와 명령어를 포함한다.

워킹셋 개념은 프로세스의 지역성(Locality) 원리에 기반하여 설명된다. 

프로세스가 실행 중일 때 일부 페이지만 주로 사용되고, 나머지 페이지는 거의 사용되지 않을 수 있다. 따라서 워킹셋은 주 메모리에 유지되어야 할 최소한의 페이지 집합으로 간주된다.

워킹셋은 다음과 같은 중요한 특성을 가진다.

1. 지역성(Locality):

    워킹셋은 프로세스가 실행 중에 자주 참조하는 데이터와 명령어에 집중되어 있다. 프로세스는 일반적으로 특정 시간 동안 일부 페이지만을 활발하게 사용하므로, 워킹셋은 이러한 활발하게 사용되는 페이지의 집합을 반영한다.

2. 시간적 지역성(Temporal Locality):

    프로세스가 특정 페이지를 참조한 후 일정 시간 동안 다시 해당 페이지를 참조할 확률이 높다. 따라서 워킹셋은 최근에 자주 참조된 페이지를 포함한다.

3. 공간적 지역성(Spatial Locality):

    프로세스가 특정 페이지를 참조한 후 주변에 위치한 페이지를 참조할 확률이 높다. 따라서 워킹셋은 최근에 자주 참조된 페이지와 해당 페이지와 관련된 주변 페이지를 포함한다.
    
워킹셋 개념은 메모리 관리에서 중요한 역할을 한다. 운영체제는 워킹셋을 기반으로 주 메모리에 유지되어야 할 페이지의 양을 결정하고, 프로세스의 성능을 최적화하는 데 사용된다. 워킹셋을 유지하는 데 필요한 페이지를 주 메모리에 유지함으로써 페이지 폴트가 발생하는 빈도를 줄이고, 프로세스의 성능을 향상시킬 수 있다.

</details>

### 페이지 교체 실습코드
<details>
<summary>21.fifo.py 코드 펼쳐보기</summary>

```python
"""
페이지교체 중 선입 선출 방식을 코드로 구현해보자.
"""

class PageReplacementFIFO :
    def __init__(self, capacity):
        self.capacity = capacity
        self.pages = []

    def access_page(self, page):
        if page not in self.pages:
            if len(self.pages) >= self.capacity:
                self.pages.pop(0) # 제일 앞의 페이지를 제거
            self.pages.append(page) # 새로들어온 페이지를 추가

    def status(self):
        print("현재 페이지 상태 : ", self.pages)

page_replacement = PageReplacementFIFO(capacity=3)
page_replacement.status()

# 4부터는 선입선출이 적용되어야한다. capacity가 3이기 때문에.
for i in range(1,6):
    page_replacement.access_page(i)
    page_replacement.status()
```

</details>