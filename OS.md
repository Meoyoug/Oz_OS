# 운영체제(OS)란?
![정의](/이미지/스크린샷%202024-03-14%20오전%2010.43.24.png)

운영체제란 컴퓨터에 포함된 cpu나 메모리, 입출력 기기등이 사용자의 기대에 맞게 역핳을 수행할 수 있도록 도와주는 창구역할을 하는 시스템 소프트웨어이다. 이러한 역할 때문에 '플랫폼 소프트웨어'라고도 불린다. 사용 기기나 목적에 따라 필요한 운영체제의 유형이 다르기 때문에 종류 또한 무척이나 다양하다.

## 운영체제의 대표적인 역할

- 프로세스 관리
- 메모리관리
- 파일 시스템 관리

## 운영체제의 구조
![구조](/이미지/스크린샷%202024-03-14%20오전%2010.52.15.png)

- `응용프로그램` :  사용자가 컴퓨터에서 특정 작업을 수행하기 위해 사용하는 소프트웨어입니다. 응용프로그램은 사용자가 원하는 작업을 수행하고 결과를 얻는 데 사용된다. 응용프로그램은 일반적으로 운영 체제 위에서 실행되며, 사용자가 그래픽 사용자 인터페이스(GUI)나 명령줄 인터페이스(CLI)를 통해 상호작용할 수 있다.
<br>
<br>
 
- `커널` : 커널은 컴퓨터 운영 체제의 핵심 부분으로, 하드웨어와 소프트웨어 간의 상호 작용을 관리하고 제어한다.
    - 주요 기능
        1. 자원관리
        2. 프로세스 관리
        3. 장치 드라이버 관리
        4. 메모리 관리
        5. 파일 시스템 관리

    - 인터페이스
        1. `CLI(Command Line Interface)`: 컴퓨터 프로그램과 사용자 간의 상호 작용을 위한 텍스트 기반 인터페이스. CLI는 사용자가 명령어를 입력하여 컴퓨터에 명령을 전달하고 결과를 받는 방식으로 동작한다. 텍스트 명령을 통해 파일을 생성, 복사, 이동, 삭제하거나 프로그램을 실행하는 등의 작업을 수행할 수 있다.
        CLI는 효율적인 작업 처리나 자동화된 작업을 위해 많이 사용됩니다. CLI는 텍스트 기반으로 작동하기 때문에 GUI보다 더 빠르고 자동화하기 쉽다는 장점이 있다.

        2. `GUI(Graphic User Interface)`: 사용자가 컴퓨터와 상호작용할 수 있도록 그래픽으로 구성된 환경을 제공하는 인터페이스. 사용자는 마우스, 키보드 또는 터치 스크린 등을 사용하여 그래픽으로 표시된 아이콘, 창, 버튼 등을 클릭하거나 조작하여 작업을 수행할 수 있다.
<br>
<br>

- `시스템 콜` : 운영 체제 커널이 제공하는 서비스에 대한 인터페이스를 제공하는 소프트웨어 요청. 프로그램이 운영 체제의 기능을 사용하려고 할 때, 그 프로그램은 시스템 콜을 호출하여 운영 체제에게 해당 기능을 요청한다.
    - 용도
        1. `자원 접근` : 파일 시스템, 네트워크, 디바이스 드라이버 등과 같은 시스템 자원에 접근하기 위해 사용됩니다. 예를 들어, 파일을 열거나 닫는 데 사용

        2. `프로세스 제어` : 새 프로세스를 생성하거나 종료하는 등의 프로세스 관리 작업을 수행

        3. `메모리 관리` : 메모리 할당 및 해제, 메모리 보호 등과 같은 메모리 관리 작업을 수행

        4. `프로세스간 통신` : 프로세스 간의 통신을 위해 사용될 수 있습니다. 이는 파이프, 소켓, 메시지 큐 등을 통해 이루어짐

        5. `시스템 정보의 조회 및 변경` : 운영 체제에서 제공하는 시스템 정보를 조회하거나 변경하기 위해 사용
<br>
<br>

![하드웨어구성](/이미지/스크린샷%202024-03-14%20오전%2011.23.13.png)

- `하드웨어` : 컴퓨터 시스템의 물리적인 부분으로, 전기적, 기계적, 전자적인 장치들의 집합을 의미. 하드웨어는 소프트웨어가 실행되고 데이터를 처리하는 데 필요한 모든 물리적 구성 요소를 포함한다.

    - 구성요소
        1. `CPU(중앙 처리 장치)` : 프로그램의 명령어를 해석하고 실행하는 역할을 담당. CPU는 산술 및 논리 연산을 수행하고, 프로그램의 제어 흐름을 관리한다.

        2. `메인 메모리` : 데이터와 명령어를 저장하는 장치로, CPU에 의해 빠르게 접근할 수 있다. 주 메모리로는 RAM(Random Access Memory)이 있으며, CPU가 직접 접근하여 데이터를 읽고 쓸 수 있는 주 기억 장치로, 컴퓨터의 작업 공간으로 생각할 수 있다. 메인 메모리는 컴퓨터 시스템이 실행 중인 프로그램의 코드와 데이터를 저장하는 데 사용된다. 전원이 꺼지면 데이터가 사라지는 휘발성 저장 장치이다.

        3. `입출력 장치` : 데이터를 시스템으로 입력하거나 시스템에서 출력하는 데 사용. 키보드, 마우스, 모니터, 프린터, 스캐너, 네트워크 카드 등이 이에 해당한다.

        4. `보조 기억 장치(Auxiliary Storage)` : 데이터를 영구적으로 저장하는 데 사용된다. 주로 대용량의 데이터 및 프로그램 파일을 저장하는 데 사용된다. 일반적인 보조 기억 장치로는 하드 디스크 드라이브(HDD), 솔리드 스테이트 드라이브(SSD), 광 디스크 등이 있다. 보조 기억 장치는 전원이 꺼져도 데이터가 보존되므로 영구 저장 장치로 알려져 있다.

        5. `버스(Bus)` : 하드웨어 간 데이터 및 제어 신호를 전송하는 통신 경로. CPU, 메모리, 입출력 장치 등이 이를 통해 통신한다.

        6. `시스템 보드(System Board)` : 다른 하드웨어 구성 요소들을 연결하고 지원하기 위한 메인 보드입니다. CPU 소켓, 메모리 슬롯, 확장 슬롯 등이 있다.

    - CPU 세부구성
        1. `ALU (Arithmetic Logic Unit, 산술 논리 장치)` :
        ALU는 컴퓨터의 중앙 처리 장치(CPU) 내에서 연산을 수행하는 부분이다.
        산술 연산(덧셈, 뺄셈, 곱셈, 나눗셈 등)과 논리 연산(AND, OR, NOT, XOR 등)을 수행한다.
        ALU는 레지스터에 저장된 데이터를 읽어와서 연산을 수행하며, 연산 결과를 다시 레지스터에 저장한다.
        컴퓨터의 연산 속도 및 성능은 ALU의 성능에 크게 의존한다.
        
        2. `CU (Control Unit, 제어 장치)` :
        CU는 CPU 내에서 바이너리 명령어(ex. 1110001100101)를 해석하고 실행하는 부분이다.
        명령어를 해독하여 해당하는 연산이나 데이터 전송 등을 수행하기 위해 다른 하드웨어 장치를 제어한다.
        명령어의 실행 순서를 제어하고, 연산 장치 및 메모리 간의 데이터 흐름을 조정한다.
        CU는 ALU와 메모리 간의 데이터 전송을 조정하고, 프로그램 카운터를 업데이트하여 다음 실행할 명령어의 위치를 지정한다.
        
        3. `Register Set (레지스터 세트)` :
        레지스터 세트는 CPU 내에 있는 고속 메모리로, CPU 내부에서 데이터를 일시적으로 저장하고 처리하는 데 사용된다.
        레지스터는 매우 빠른 속도로 접근할 수 있으며, CPU의 연산에 필요한 중요한 데이터를 보관한다.
        레지스터는 CPU의 일부분으로, 명령어의 실행에 필요한 데이터를 저장하거나 임시로 연산 결과를 저장한다.
        대부분의 CPU는 여러 종류의 레지스터를 포함하고 있으며, 이러한 레지스터들은 연산에 필요한 주소, 연산 결과, 연산에 필요한 데이터 등을 저장한다.

    - 메인 메모리와 보조 기억 장치의 주요 차이점
        1. 접근 속도와 용도
            - 메인 메모리 : 메인 메모리는 CPU가 직접 접근하여 데이터를 읽고 쓸 수 있는 주 기억 장치이다. 메인 메모리는 CPU와 매우 가까이 위치하며 매우 빠른 접근 속도를 가지고 있다. 프로그램이 실행될 때 필요한 데이터와 명령어가 메인 메모리에 로드되어 CPU에 의해 처리된다.

            - 보조 기억 장치 : 보조 기억 장치는 메인 메모리보다 접근 속도가 느리지만, 더 큰 저장 용량을 가지고 있다. 주로 대용량 데이터 및 프로그램 파일을 저장하는 데 사용된다. 
        
        2. 가격과 용량
            - 메인 메모리 : 메인 메모리는 비교적 작은 용량을 가지지만, 비용이 더 비싸고 접근 속도가 빠르다. 대개 몇 기가바이트에서 수십 기가바이트 정도의 용량을 가진다.

            - 보조 기억 장치 : 보조 기억 장치는 대용량의 데이터를 저장할 수 있으며, 비교적 저렴한 가격에 높은 용량을 제공한다. 수백 기가바이트에서 수 테라바이트 이상의 용량을 가질 수 있다.

        3. 지속성
            - 메인 메모리 : 전원이 꺼지면 메인 메모리에 저장된 데이터가 사라진다(휘발성). 따라서 메인 메모리는 일시적인 데이터 저장에 사용된다.

            - 보조 기억 장치 : 보조 기억 장치는 전원이 꺼져도 데이터가 유지됩니다(보존성, 영구성). 따라서 영구적인 데이터 저장에 사용된다.
<br>
<br>

- `드라이버` : 컴퓨터의 하드웨어 장치를 제어하고 관리하기 위한 소프트웨어. 운영 체제와 하드웨어 간의 통신을 중개하며, 하드웨어를 컴퓨터에서 올바르게 작동하도록 지원한다.
    - 기능
        1. `하드웨어 제어` : 드라이버는 하드웨어를 제어하고 관리. 이는 하드웨어의 동작을 초기화하고 설정하는 것을 포함한다.

        2. `운영 체제와의 통신` : 드라이버는 운영 체제와의 통신을 담당. 하드웨어의 상태를 보고하고, 운영 체제로부터 명령을 받아 하드웨어를 제어한다.

        3. `자원 할당 및 해제` : 운영 체제가 하드웨어 자원을 할당하거나 해제할 때, 이러한 작업을 처리하는 데 드라이버가 필요.

        4. `오류 처리 및 예외 처리` : 드라이버는 하드웨어에서 발생하는 오류를 감지하고 처리한다. 이는 예기치 않은 상황에 대비하여 안정성과 신뢰성을 높이는 데 도움이 된다.

## CPU의 이해
![CPU구조](/이미지/스크린샷%202024-03-14%20오전%2011.42.27.png)

ALU, CU, 레지스터 세트는 협력하여 CPU가 프로그램을 실행하고 데이터를 처리하는 데 필요한 모든 기능을 제공한다. CU는 명령어를 해석하고 제어 신호를 발생시켜 ALU 및 다른 하드웨어 구성 요소를 조정하며, ALU는 주어진 연산을 수행하고 레지스터 세트는 데이터를 저장하고 보유한다. 이러한 구성 요소들은 CPU의 동작을 조정하여 프로그램의 명령어를 실행하고 결과를 생성한다.

- ALU(산술 논리 장치)
    - 기능 : ALU는 주어진 연산을 수행한다. 예를 들어, 두 개의 숫자를 더하는 경우, ALU는 덧셈 연산을 수행하여 결과를 생성한다. 더하기, 빼기, 곱하기, 나누기와 같은 산술 연산 뿐만 아니라 논리 연산(AND, OR, NOT 등)도 수행할 수 있다.
    
- CU(제어 장치)
    - 기능 : CU는 바이너리 명령어의 해석과 실행을 담당합니다. 먼저, CU는 메모리에서 명령어를 가져와 해석다. 명령어가 무엇을 수행해야 하는지를 인식하고, 해당하는 제어 신호를 발생시켜 ALU나 메모리, 레지스터 등에 필요한 작업을 지시한다.

- 레지스터 세트(Register Set)

    - 기능 : 데이터 저장 및 임시 결과 보유한다. 레지스터는 CPU 내부에 있는 작은 저장 공간으로, 빠른 액세스 속도를 제공한다. 레지스터 세트에는 다양한 목적으로 사용되는 여러 레지스터가 포함될 수 있다. 예를 들어, 데이터를 임시로 저장하거나 연산 중에 발생한 중간 결과를 보유하는 데 사용된다.

    - 종류
        1. `프로그램 카운터(Program Counter)`
            - 기능 : 다음에 실행할 명령어의 메모리 주소를 저장하는 역할을 한다.

            - 동작 : CPU는 프로그램 카운터가 가리키는 메모리 주소에서 명령어를 가져와 실행한다. 프로그램이 실행되는 동안, 프로그램 카운터는 명령어의 실행 순서를 추적하고 다음에 실행할 명령어의 위치를 나타낸다. 명령어가 실행되면 프로그램 카운터는 다음 명령어의 주소로 업데이트되어야 한다. 프로그램의 흐름을 제어하고 다음에 실행할 명령어를 결정하는 데 중요한 역할을 한다. 

        2. `인스트럭션 레지스터(Instruction Register, IR)`
            - 기능 : 현재 실행 중인 명령어를 저장하는 데 사용된다. CPU가 메모리로부터 명령어를 가져와 해석하고 실행할 때, 해당 명령어는 인스트럭션 레지스터에 저장된다.

            - 동작 : 인스트럭션 레지스터는 CPU가 현재 실행 중인 명령어를 유지하는 역할을 다. 명령어가 실행되는 동안, 인스트럭션 레지스터는 해당 명령어의 내용을 유지하고 CPU가 명령어를 해석하고 실행하는 데 필요한 정보를 제공한다.
            일반적으로 CPU는 메모리로부터 명령어를 가져와 인스트럭션 레지스터에 로드한 후, 해당 명령어를 해석하고 실행한. 명령어의 실행이 완료되면 다음 명령어가 로드되어 인스트럭션 레지스터에 저장된다. 이와 같은 방식으로 CPU는 프로그램의 명령어를 한 번에 하나씩 순차적으로 실행한다.

        3. `어드레스 레지스터(Address Register)`
            - 기능 : 메모리 주소를 저장하는 데 사용된다. CPU가 메모리나 입출력 장치와 통신할 때, 어드레스 레지스터는 해당 장치의 주소를 저장하고 전송한다. CPU와 다른 하드웨어 장치 간의 데이터 통신에서 사용되며, 데이터의 안정적인 전송을 보장하는 데 중요한 역할을 다. 데이터를 임시로 저장하고 필요할 때 전송함으로써 시스템의 효율성과 안정성을 향상시킨다.

            - 동작 : 어드레스 레지스터는 주로 주소 계산 및 메모리 주소 지정에 사용된다. 프로세서가 메모리에서 데이터를 읽거나 쓰려면 어드레스 레지스터에 목표 메모리 주소를 로드하고 해당 주소로 데이터를 전송한다. 또한 입출력 장치와의 통신에도 사용될 수 있다.
            어드레스 레지스터는 메모리 액세스 또는 입출력 작업이 필요한 때에만 사용된다. 명령어를 실행하는 동안 CPU는 필요한 메모리 주소를 어드레스 레지스터에 로드하여 데이터를 읽거나 쓸 수 있다.

        4. `버퍼 레지스터(Buffer Register)`
            - 기능 : 데이터가 임시로 저장되는 레지스터로, 데이터를 한 곳에서 다른 곳으로 전송하는 데 사용된다. 버퍼 레지스터는 데이터를 보유하고 필요할 때 다른 장치로 전송하는 역할을 한다.

            - 동작 : 버퍼 레지스터는 입력과 출력 간의 데이터 흐름을 조절하며, 데이터를 안정적으로 전송하는 데 도움이 된다. 예를 들어, 입력 장치에서 CPU로 데이터를 전송하거나, CPU에서 출력 장치로 데이터를 보내는 경우에 사용될 수 있다.
            또한, 버퍼 레지스터는 데이터 전송 과정에서 속도 차이를 조절하는 데 사용될 수 있다. 속도가 빠른 장치와 느린 장치 간의 데이터 전송에서 버퍼 레지스터는 데이터의 흐름을 조절하여 데이터 손실이나 오류를 방지한다.

        5. `플래그 레지스터(Flag Register)`
            - 기능 : 프로세서의 상태를 나타내는 데 사용된다. 플래그 레지스터에는 연산 결과나 프로세서의 상태에 대한 여러 플래그(Flag)가 저장된다.

            - 주요 플래그
                1. `제로 플래그(Zero Flag, Z)` : 최근에 수행된 연산의 결과가 0이면 제로 플래그가 설정된다. 이 플래그는 주로 비교 연산 결과를 확인할 때 사용된다.

                2. `부호 플래그(Sign Flag, S)` : 최근에 수행된 연산의 결과가 음수이면 부호 플래그가 설정된다.

                3. `오버플로 플래그(Overflow Flag, O)` : 최근에 수행된 연산의 결과가 특정 범위를 초과하면 오버플로 플래그가 설정된다.

                4. `캐리 플래그(Carry Flag, C)` : 최근에 수행된 연산에서 발생한 캐리(자릿수 올림)가 있는 경우 캐리 플래그가 설정된다.

                5. `패러티 플래그(Parity Flag, P)` : 최근에 수행된 연산의 결과에 비트 수가 짝수이면 패러티 플래그가 설정된다.

            - 동작 : 플래그 레지스터는 프로세서의 상태를 확인하고 제어하는 데 중요한 역할을 한다. 프로그램이 실행되는 동안 플래그 레지스터의 상태를 확인하여 프로그램의 제어 흐름을 조정하거나 조건 분기를 수행할 수 있다. 특히, 비교 연산과 같은 조건부 명령어에서 플래그 레지스터의 값이 사용된다.

        6. `스택 포인터(Stack Pointer)`
            - 기능 : 프로그램이 실행되는 동안 사용되는 중요한 레지스터 중 하나입니다. 스택(Stack)은 메모리의 일부분으로, 데이터를 임시로 저장하는데 사용된다.

            - 동작 : 스택은 후입선출(Last In First Out, LIFO)의 구조를 가지고 있어 데이터가 쌓이는 방식으로 작동한다.
            스택 포인터는 현재 스택의 맨 위에 있는 데이터의 위치를 가리키는 역할을 한다. 스택은 메모리의 일부분을 차지하므로 스택 포인터는 메모리 주소를 가리키며, 스택의 최상위 데이터의 위치를 가리킨다. 스택 포인터는 스택에 데이터를 푸시(push)하거나 팝(pop)할 때 사용되며, 스택의 크기가 동적으로 변경될 때 포인터가 조정된다.
            스택 포인터는 일반적으로 메모리의 상단부에서 하향식으로 증가하는 방식으로 동작한다. 이는 새로운 데이터가 스택에 푸시될 때마다 스택 포인터가 증가하여 새 데이터의 위치를 가리키게 된다. 반대로 데이터가 스택에서 팝될 때마다 스택 포인터가 감소하여 스택의 최상위 데이터의 위치를 변경한다.
            스택 포인터는 프로그램의 실행 중에 스택에 데이터를 저장하고 검색하는 데 사용되며, 서브루틴 호출, 지역 변수 저장, 함수 호출 및 복귀 등 다양한 프로그램 작업에 활용된다. 스택 포인터는 프로그램의 실행 흐름을 제어하고 임시 데이터를 안전하게 저장하는 데 중요한 역할을 한다.

- 클럭 펄스(Clock Pulse)
    ![클럭펄스](/이미지/main-qimg-8aee230fe57a7f3b03593bc8b33874a9-lq.jpeg)

    디지털 시스템에서 주기적으로 발생하는 전압 또는 전류의 변화입니다. 클럭 펄스는 일종의 신호로, 전자 장치의 동작을 조절하고 동기화하는 데 사용된다. 

    일반적으로 클럭 펄스는 일정한 주기로 반복되는 사각파(Square Wave) 형태의 신호로 표현됩니다. 각 클럭 펄스는 시스템의 하나의 클럭 주기를 나타내며, 클럭 주기에 따라 시스템의 작업이 진행된다.

    클럭 펄스의 주기는 클럭 속도(Clock Speed) 또는 클럭 주파수(Clock Frequency)로 표현된다. 이는 1초 동안 발생하는 클럭 펄스의 횟수를 나타내며, 주로 헤르츠(Hertz, Hz) 단위로 표시된다. 클럭 속도가 높을수록 시스템은 더 많은 클럭 펄스를 처리하고 데이터를 전송할 수 있다.

    클럭 펄스는 컴퓨터 시스템의 모든 구성 요소에 의해 사용되며, CPU, 메모리, 입출력 장치 등의 동작을 동기화하여 데이터의 안정적인 전송과 처리를 보장한다. 또한 클럭 펄스는 시스템의 전원 소비를 최적화하고, 오버클럭킹(Overclocking)과 같은 작업에서 성능을 향상시키는 데에도 사용될 수 있다.

## 프로그램 실행 과정
- 기본 구조
    ![코드 과정](/이미지/스크린샷%202024-03-14%20오후%204.10.13.png)
<br>
<br>
- 실행파일의 실행 과정
    ![컴파일과정](/이미지/스크린샷%202024-03-14%20오후%204.11.31.png)
<br>
<br>
- 메모리에서 cpu로 진행되는 과정
    ![과정](/이미지/스크린샷%202024-03-14%20오후%204.13.55.png)
    
    1. Fetch : 메모리에 저장된 명령어를 cpu로 가져오기 위한 과정. 인스트럭션 레지스터를 사용한다.
        - CPU는 메모리에서 다음에 실행할 명령어를 가져오기 위해 프로그램 카운터(PC)에 저장된 주소를 사용한다.
        - 프로그램 카운터는 메모리에서 명령어의 위치를 가리키는 포인터로 사용된다.
        - CPU는 프로그램 카운터가 가리키는 주소로 이동하여 해당 명령어를 메모리에서 읽어온다.
        - 읽어온 명령어는 명령어 레지스터(IR)에 저장된다.

    2. Decode : 가져온 명령어를 해독하고 이해하는 과정, 명령어의 종류를 식별하고 필요한 데이터를 추출하는 등의 작업을 수행한다. CU가 담당하는 부분이다.
        - 가져온 명령어는 명령어 레지스터(IR)에 저장되어 있으며, CPU는 이 명령어를 해석한다.
        - 명령어는 그 종류에 따라 다른 동작을 수행해야 하기 때문에, CPU는 명령어의 종류를 식별하고 해당하는 작업을 수행할 수 있는 준비를 합니다.

    3. Execution : 해석된 명령어를 수행하는 단계이다. ALU의 담당 부분이다.
        - CPU는 명령어에 따라 필요한 작업을 수행하고, 데이터를 처리하거나 제어 흐름을 변경한다.
        - 산술 연산을 수행하거나 메모리에 데이터를 저장하는 등의 작업이 이루어진다.
<br>
<br>
- 버스 시스템을 통한 데이터 이동
    ![Bus](/이미지/스크린샷%202024-03-14%20오후%204.17.46.png)

### 폰 노이만 구조
![폰노이만](/이미지/스크린샷%202024-03-14%20오후%204.04.49.png)

폰 노이만 구조는 현대 컴퓨터 아키텍처의 중요한 출발점이며, 대부분의 일반적인 컴퓨터 시스템이 이러한 구조를 기반으로 설계되어 있다.

폰 노이만 구조(또는 폰 노이만 아키텍처)는 컴퓨터 시스템의 설계 구조 중 하나로, 프로그램과 데이터가 메모리에 저장되고, 중앙 처리 장치(CPU)가 이를 순차적으로 처리하는 방식을 나타낸다. 

- 특징
    1. `프로그램과 데이터의 분리` : 폰 노이만 구조에서는 프로그램과 데이터가 메모리에 동일한 형태로 저장된다. 이는 프로그램이 데이터와 동일한 방식으로 처리될 수 있음을 의미한다. 따라서 프로그램은 수정되지 않고도 CPU가 새로운 명령어를 실행할 수 있다.

    2. `명령어의 순차적 실행` : CPU는 메모리에 저장된 프로그램의 첫 번째 명령어부터 시작하여 순차적으로 실행된다. 각 명령어는 메모리에서 읽히고 해독되어 해당하는 작업을 수행한다. 이러한 구조는 프로그램의 흐름을 단순화하고 제어를 용이하게 한다.

    3. `명령어와 데이터의 통합된 버스` : 폰 노이만 구조에서는 명령어와 데이터가 동일한 버스를 통해 CPU와 메모리 간에 전송된다. 이는 명령어와 데이터를 읽고 쓰는 데 사용되는 인터페이스를 단순화한다.

    4. `바이너리 연산` : 폰 노이만 구조에서는 모든 명령어와 데이터가 이진수(binary) 형식으로 표현된다. 이는 컴퓨터의 기본적인 데이터 표현 방식이며, 모든 연산은 이진수로 표현되어 처리된다.


## 인터럽트(Interrupt)
`인터럽트(Interrupt)`는 CPU가 어떤 작업을 수행하고 있을 때, 작업을 방해하는 신호를 가리키는 말이다.

CPU가 현재 수행 중인 작업을 중단하고 다른 작업을 처리할 수 있도록 하는 메커니즘이다.

인터럽트가 발생하면 CPU는 현재 실행 중인 작업을 일시 중단하고 인터럽트를 처리하기 위한 인터럽트 서비스 루틴(Interrupt Service Routine, ISR)으로 제어를 이전한다. ISR은 해당 인터럽트의 원인을 처리하고, 필요한 작업을 수행한 후에는 원래 실행 중이던 작업으로 복귀한다.

인터럽트는 시스템의 효율성과 다양한 장치와의 상호 작용을 가능하게 한다.

CPU에서는 정상적으로 수행할 수 없는 명령어가 입력되면 인터럽트를 발생시키기도 하는데, 이렇게 발생하는 인터럽트를 가리켜 `동기 인터럽트`나 `예외` 라고 부르기도 한다.

입출력 장치(하드웨어)로부터 발생하는 인터럽트는 `비동기 인터럽트`라고 표현한다.

- 인터럽트 서비스 루틴(Interrupt Service Routine, ISR) or 인터럽트 핸들러
: 인터럽트를 처리하기 위해 특정 인터럽트 신호에 미리 정의되어 있는 프로그램 또는 함수이다.

1. 내부 인터럽트(Internal Interrupt): CPU 내부에서 발생하는 인터럽트로, 주로 프로그램 실행 도중에 발생하는 오류나 예외 상황에 의해 유발된다. 예를 들어, 연산 오버플로우(Overflow)나 잘못된 명령어 실행 등이 있다.

2. 외부 인터럽트(External Interrupt): 외부 장치나 외부 이벤트에 의해 발생하는 인터럽트이다. 이러한 인터럽트는 주로 입출력 장치의 작업 완료, 하드웨어 오류, 타이머 인터럽트 등에 의해 발생한다.

- 인터럽트 핸들러 실습

    [1. interrupt.py](/실습파일/1.%20interrupt.py)

    <details>
    <summary>1. interrupt.py 코드 펼쳐보기</summary>
    
    ```python
    # 인터럽트 예제

    import time
    import signal # 신호 처리 라이브러리, 비동기 인터럽트에 대한 핸들러

    # signum : 인터럽트의 유형 번호
    # frame : 메모리영역 중 스택 영역의 정보
    # 아래함수는 인터럽트 서비스 루틴, 인터럽트 핸들러의 역할

    def signal_handler(signum, frame):
        print("키보드 인터럽트 감지")
        print('신호 번호 : ', signum)
        print('스택 프레임 : ', frame)
        exit() # 무한루프를 돌리다가 인터럽트 발생시 강제종료

    # signal.SIGINT 키보드 인터럽트 상수
    signal.signal(signal.SIGINT, signal_handler)

    while True:
        print('5초 간격으로 출력중...')
        time.sleep(5)
    ```
    </details>
<br>
<br>

# 프로세스란?

실행중인 프로그램을 뜻한다. 프로그램을 실행하기 위해서 운영체제는 필요한 자원을 할당하고 관리하기 시작한다.

하나의 프로세스는 실행 중인 프로그램의 인스턴스로, 메모리에 할당된 리소스와 실행 상태를 가지고 있다.

각각의 프로세스는 독립적으로 실행되며, 다른 프로세스와는 독립된 메모리 공간을 가진다.

프로세스는 컴퓨터 시스템에서 중요한 개념으로, 다양한 응용 프로그램이 동시에 실행되고 관리될 수 있도록 한다. 

각 프로세스는 실행 중인 프로그램의 상태를 나타내며, 운영 체제에 의해 관리되어 효율적으로 리소스를 사용하고 실행된다.
<br>
<br>
## 프로세스의 구조
![프로세스 구조](/이미지/스크린샷%202024-03-15%20오전%2010.07.31.png)

- 코드영역 : 프로세스가 실행할 명령어들의 집합. 코드 세그먼트에는 프로그램의 명령어들이 메모리에 저장되어 있으며, CPU가 이를 실행한다.

- 데이터 영역 :  프로세스가 사용하는 전역 변수, 정적 변수, 상수 등이 저장된다. 이 세그먼트는 초기화된 데이터와 초기화되지 않은 데이터(BSS 세그먼트)로 나뉜다.

- 스택 영역 : 프로세스의 함수 호출 및 지역 변수를 저장하는 데 사용된다. 함수가 호출될 때마다 스택에 새로운 프레임이 생성되며, 함수가 반환될 때 이전 프레임이 제거된다. -> 휘발성 데이터

- 힙 영역 : 동적으로 할당된 메모리를 저장하는 데 사용된다. 힙은 프로세스의 실행 중에 동적으로 메모리를 할당하고 해제할 수 있으며, 주로 동적으로 생성된 객체나 데이터 구조를 저장한다.

- 레지스터 영역 : CPU 내부에 있는 작은 메모리 공간으로, 프로세스의 실행 중에 현재 실행 중인 명령어나 데이터를 일시적으로 저장하는 데 사용된다. 레지스터에는 프로그램 카운터(PC), 스택 포인터(SP), 베이스 레지스터(BP) 등이 포함된다.
<br>
<br>

### 프로세스 존재 확인 실습 코드

<details>
<summary>2. process.py - 파이썬 프로세스 할당 코드 펼쳐보기</summary>

```python
# 파이썬 프로그램도 프로세스가 될 수 있다.
# 파이썬 코드 동작시 할당되는 프로세스의 아이디를 확인하는 코드
import os

# os.getpid() -> 프로세스 아이디를 가져옴
print('파이썬 코드 실행중.. 실행중인 프로세스 아이디는 : ', os.getpid())
```
</details>

<details>
<summary>2. process.py - 크롬 프로세스 확인 펼쳐보기</summary>

```python

# 내 컴퓨터에서 돌아가는 크롬에 해당하는 프로세스 조회하기
# pip install psutil
import psutil

# 프로세스들에 반복적으로 접근하여 개별 프로세스의 이름을 가져옴
for proc in psutil.process_iter():
    process_name = proc.name()
    # 프로세스의 이름에 크롬이 포함되어있으면 프린트.
    if "chrome" in process_name:
        print(process_name, proc.pid)
```

</details>
<br>
<br>

## 프로세스 상태
![프로세스 상태 변화](/이미지/스크린샷%202024-03-15%20오전%2010.34.20.png)
```
- 생성(Created): 프로세스가 생성되었지만 아직 실행되지 않은 상태. 이 상태에서는 운영체제가 프로세스를 초기화하고 필요한 자원을 할당한다.

- 준비(Ready): 프로세스가 실행을 기다리는 상태. 준비 상태에 있는 프로세스는 CPU를 사용할 준비가 되어 있지만, 아직 CPU를 할당받지 못한 상태이다.

- 실행(Running): CPU를 사용하여 명령어를 실행하는 상태. 실행 상태에 있는 프로세스는 현재 CPU를 사용하고 있다.

- 대기(Waiting 또는 Blocked): 프로세스가 어떤 이벤트를 기다리는 상태. 예를 들어, 입출력 완료를 기다리거나, 특정 자원의 사용 허가를 기다리는 경우가 있을 수 있다.

- 종료(Terminated 또는 Exit): 프로세스가 실행을 완료하고 종료된 상태. 종료된 프로세스는 운영체제에 의해 메모리에서 해제되고 관련된 자원이 반환된다.
```

프로세스는 이러한 상태를 변경하면서 실행된다. 보통은 cpu는 하나의 프로세스만 실행가능 하기 때문에 생성 → 준비 → 실행 → 대기 → 실행 → 대기 → ... → 종료 의 순서로 상태가 변경된다.

준비 상태에서 실행 상태로 전환하기 위해서는 CPU 스케줄러에 의해 선택되어 CPU를 할당받아야 한다. 

대기 상태에서 실행 상태로 전환하기 위해서는 해당 이벤트가 발생하여 대기 상태를 벗어나야 한다.
<br>
<br>
### 프로세스 제어 블록(Process Control Block, PCB)

CPU는 한 번에 하나의 연산을 수행할 수 있기 때문에 여러 개의 프로세스를 동시에 실행하지 않고 빠르게 번갈아가면서 실행하게 된다.

이를 위해 운용체제는 PCB를 만들어서 관리하는데, 여기에는 프로세스를 식별하기 위해서 필요한 정보들이 저장된다.
ex. process ID, register data, scheduling config, status ...

PCB는 각 프로세스에 대해 운영체제가 유지하는 정보이므로, 프로세스가 생성되고 종료될 때마다 PCB가 생성되거나 삭제됩니다. PCB는 프로세스의 상태 변화에 따라 업데이트되며, 운영체제가 프로세스를 스케줄링하고 제어하는 데 필요한 핵심 데이터를 제공한다.

- PCB에 포함되는 정보
    1. `프로세스 상태(Process State)` : 프로세스의 현재 상태. 예를 들어, 실행 중인지 대기 중인지, 중단되었는지 등을 나타낸다.

    2. `프로그램 카운터(Program Counter, PC)` : 다음에 실행할 명령어의 주소를 가리키는 레지스터 값.

    3. `레지스터 상태(Register State)` : CPU 레지스터의 내용을 저장한다. 이는 프로세스가 중단되었을 때 해당 레지스터 값을 저장하고, 다시 실행될 때 해당 레지스터 값을 복원하는 데 사용된다.

    4. `스케줄링 정보(Scheduling Information)` : 프로세스가 CPU를 사용할 수 있는 우선순위, 스케줄링 알고리즘에 필요한 정보 등을 포함한다.

    5. `메모리 관리 정보(Memory Management Information)` : 프로세스가 사용하는 메모리 영역의 크기와 위치를 포함한다. 이 정보는 가상 메모리 시스템에서 중요한 역할을 한다.

    6. `입출력 상태(Input/Output State)` : 프로세스가 대기 중인 입출력 작업과 관련된 정보를 포함한다. 이 정보는 입출력 작업이 완료되면 프로세스를 깨워 다시 실행되도록 하는 데 사용된다.


### 프로세스 계층
![계층](/이미지/스크린샷%202024-03-15%20오전%2010.44.37.png)

프로세스 계층(Process Hierarchy)은 운영체제에서 프로세스 간의 부모-자식 관계를 의미한다. 

일반적으로는 부모 프로세스가 자식 프로세스를 생성하는 방식으로 계층 구조가 형성된다. 

부모-자식간의 프로세스는 각각 독립적인 영역을 가진다.

이러한 계층 구조는 다양한 운영체제에서 프로세스의 관리와 제어를 용이하게 한다.

### 프로세스 실습 코드

<details>
<summary>3. process_detail.py 코드 열어보기</summary>

```python
import psutil

for proc in psutil.process_iter() :
    process_name = proc.name()
    if "chrome" in process_name:
        # 해당 프로세스의 자식을 가져옴
        child = proc.children()
        # 프로세스이름, 상태, 부모 프로세스 모두 프린트
        print(process_name, proc.status(), proc.parent())

        # 자식프로세스가 존재하면 프린트.
        if child :
            print(f'{process_name}의 자식 프로세스 : ', child)
```

</details>

### 멀티 프로세스 운영체제

동시에 여러 개의 프로세스를 실행할 수 있는 운영체제를 의미한다. 

이러한 운영체제는 여러 개의 프로세스가 동시에 실행되고 서로 독립적으로 실행될 수 있도록 지원한다. 

각 프로세스는 각각의 메모리 공간을 할당받고, 독립적으로 실행되며, 서로 영향을 주지 않는다.

### 컨텍스트 스위칭 
![컨텍스트 스위칭](/이미지/스크린샷%202024-03-15%20오전%2011.01.47.png)

CPU가 한 프로세스에서 다른 프로세스로 전환하는 과정을 의미한다.

- 발생 시기
    1. 프로세스 스케줄링: CPU 스케줄러가 다음에 실행할 프로세스를 선택하여 CPU를 할당할 때.

    2. 인터럽트 처리: 입출력 완료, 타이머 만료 등의 이벤트가 발생하여 현재 실행 중인 프로세스를 중단하고 인터럽트 서비스 루틴이 실행될 때.

- 단계
    1. 현재 프로세스의 상태 저장: 현재 실행 중인 프로세스의 상태(레지스터 값, 프로세스 상태 등)를 해당 프로세스의 PCB에 저장한다.

    2. 다음 프로세스의 상태 로드: 다음에 실행될 프로세스의 PCB에서 상태를 읽어와 CPU 레지스터에 로드한다.

    3. 프로세스 실행: 새로운 프로세스가 실행되며, 현재 프로세스의 실행이 중단된다.
<br>
<br>

## 프로세스 생성
![프로세스 생성](/이미지/스크린샷%202024-03-15%20오전%2011.31.25.png)

프로그램 실행시, 운영체제는 코드 영역과 데이터 영역을 메인 메모리에 올리고 빈 스택과 빈 힙을 만들어 공간을 확보한다. 이는 시스템에게는 상당한 부담을 주는 일이다.

운영체제 부팅시 프로세스는 딱 한번 생성되는데 그것이 최초의 프로세스가 된다.

이후에 새로운 프로세스를 생성하는 것보다, 기존 프로세스를 복사하는 것이 더 빠르다. 따라서 모든 프로세스는 최초의 프로세스로 부터 복사된다.

이때 부모 프로세스를 복사하는 함수를 fork() 함수라고 한다.

이후에 메모리영역에 코드영역과 데이터 영역을 덮어쓰는 함수는 exec() 함수이다.

=> fork함수와 exec 함수의 반복으로 새로운 프로세스가 생성되는 것이다.

### 멀티 프로세싱 실습 코드

<details>
<summary>4. multi_processing.py - 멀티 프로세스(단일 하위 프로세스) 코드 열어보기</summary>

```python
# 같은 작업을 하는 하나의 하위 프로세스 생성
from multiprocessing import Process
import os

def func():
    print('실험용으로 만들어 본 함수')
    print('나의 프로세스 아이디: ', os.getpid())
    print('나의 부모 프로세스 아이디: ', os.getppid()) # ppid는 부모 프로세스의 아이디

if __name__ == '__main__':
    print('4.multi_processing.py 프로세스 아이디: ', os.getpid())
    child = Process(target=func).start() # target을 하위 프로세스로 만듦
```

</details>

<details>
<summary>5. multi_processing2.py - 멀티 프로세스(같은 여러개의 하위 프로세스) 코드 열어보기</summary>

```python
# 같은 작업을 하는 여러 개의 하위 프로세스 생성
from multiprocessing import Process
import os

def func():
    print('실험용으로 만들어 본 함수')
    print('나의 프로세스 아이디: ', os.getpid())
    print('나의 부모 프로세스 아이디: ', os.getppid()) # ppid는 부모 프로세스의 아이디

if __name__ == '__main__':
    print('5.multi_processing2.py 프로세스 아이디: ', os.getpid())
    # 하위 프로세스를 여러개 만들 수도 있다.(트리 구조)
    child1 = Process(target=func).start() # target을 하위 프로세스로 만듦
    child2 = Process(target=func).start() # target을 하위 프로세스로 만듦
    child3 = Process(target=func).start() # target을 하위 프로세스로 만듦
```

</details>

<details>
<summary>6. multi_processing3.py - 멀티 프로세스(다른 여러개의 하위 프로세스) 코드 열어보기</summary>

```python
# 다른 작업을 하는 여러 개의 하위 프로세스 생성
from multiprocessing import Process
import os
import time

def func1():
    print("func1 프로세스 아이디: ", os.getpid())
    print("부모 프로세스 아이디: ", os.getppid())

def func2():
    print("func2 프로세스 아이디: ", os.getpid())
    print("부모 프로세스 아이디: ", os.getppid())

def func3():
    print("func3 프로세스 아이디: ", os.getpid())
    print("부모 프로세스 아이디: ", os.getppid())

if __name__ == '__main__':
    print('6.multi_processing3.py 프로세스 아이디: ', os.getpid())
    # 각각 다른 함수를 하위 프로세스로 만든다.
    child1 = Process(target=func1).start() # func1을 하위 프로세스로 만듦
    child2 = Process(target=func2).start() # func2을 하위 프로세스로 만듦
    child3 = Process(target=func3).start() # func3을 하위 프로세스로 만듦
```

</details>

<details>
<summary>7. process_homework.py - 과제 코드 열어보기</summary>

```python
# 내 파이썬 프로그램의 이름 알아보기
# psutil을 사용해서 사용중인 프로세스 중에 
# 7. process_homework.py에 해당하는 프로세스를 찾을 경우 프린트로 출력
import os
import psutil

current_pid = os.getpid()

for proc in psutil.process_iter():
    process_id = proc.pid
    if process_id == current_pid:
        print('과제의 프로세스 이름: ', proc.name())
        print('과제의 프로세스 아이디: ', proc.pid)
        print('부모 프로세스 아이디: ', proc.ppid())
        print('부모 프로세스 이름: ', psutil.Process(proc.ppid()).name())
```

</details>
<br>
<br>

## 쓰레드(Thread)의 이해
![thread-structure](/이미지/thread_structure.png)

![프로세스-Thread](/이미지/스크린샷%202024-03-15%20오후%201.35.19.png)

쓰레드(Thread)는 프로세스 내에서 실행되는 각각의 실행 흐름을 나타낸다. 

각각의 쓰레드는 독립적으로 실행되며, 프로세스의 자원을 공유한다. 

쓰레드는 쓰레드가 하나 생성될 때마다 쓰레드를 위한 스택 영역이 추가로 생성되며, 그 이외의 코드, 데이터, 힙 영역은 공유한다.

하나의 프로세스는 여러 개의 쓰레드를 가질 수 있으며, 이러한 쓰레드들은 서로 다른 작업을 동시에 처리할 수 있다.

- 특징
    1. `경량화(Lightweight)`: 쓰레드는 프로세스 내에서 실행되기 때문에 쓰레드 간의 전환(Context Switching)이 프로세스 간의 전환보다 더 빠르다. 이는 쓰레드가 프로세스의 자원을 공유하기 때문에 프로세스 간의 문맥 교환보다 더 효율적으로 수행다.

    2. `동시성(Concurrency)`: 하나의 프로세스 내에서 여러 개의 쓰레드가 동시에 실행될 수 있다. 이는 각 쓰레드가 독립적으로 실행되기 때문에 여러 작업을 동시에 처리할 수 있다.

    3. `자원 공유(Resource Sharing)`: 쓰레드는 같은 프로세스 내에서 실행되기 때문에 프로세스의 자원(메모리, 파일 등)을 공유할 수 있다. 이를 통해 쓰레드 간에 데이터를 공유하고 통신할 수 있다.

    4. `효율성(Efficiency)`: 쓰레드를 사용하면 여러 작업을 동시에 처리할 수 있으므로 시스템 자원을 효율적으로 활용할 수 있다. 또한 쓰레드 간의 통신은 프로세스 간의 통신보다 오버헤드가 적다.

### 쓰레드 실습 코드

<details>
<summary>8.thread.py 의 실습 코드 펼쳐보기</summary>

```python
import threading
import os

def func():
    print('실험용으로 만들어 본 함수')
    print('나의 프로세스 아이디: ', os.getpid())
    print('쓰레드 아이디 : ', threading.get_native_id())

if __name__ == '__main__':
    print('기존 프로세스 아이디 : ', os.getpid())
    thread1 = threading.Thread(target=func) # target에 대한 쓰레드를 생성
    thread1.start()
```

</details>

<details>
<summary>9.thread2.py 의 실습 코드 펼쳐보기</summary>

```python
import threading
import os
import time

# 문자열 데이터를 받아 무한히 출력하는 함수
# 3초마다 문자열을 출력
def something(word):
    while True:
        print(word)
        time.sleep(3)

'''

파이썬을 실행하면 기본적으로 메인 쓰레드가 하나 생기는데, 하위 쓰레드를 만들어 별도의 쓰레드에서 something이라는 함수를 실행시킨다.

하나의 프로세스 안에서 두개의 쓰레드 (메인, 하위(데몬))을 실행시키는 구조이다.

파이썬 파일을 실행해보면 메인쓰레드의 프린터문은 1초간격으로 실행되고, 별도의 쓰레드에서 3초간격으로 다른 프린터문이 실행되는 모습을 확인할 수 있다.

'''
if __name__ == "__main__":
    print('something의 프로세스 아이디: ', os.getpid())
    thread1 = threading.Thread(target=something, args=("hello",))
    thread1.daemon = True # 데몬 쓰레드 : 메인 쓰레드가 종료되면 같이 종료되는 쓰레드 -> 활성화
    thread1.start()
    print('메인 쓰레드에서 반복문을 시작')
    while True:
        try:
            print('main thread....')
            time.sleep(1)
        except KeyboardInterrupt:
            print('메인 쓰레드 종료')
            break
```

</details>
<br>
<br>

## CPU Scheduling 의 이해

CPU 스케줄링은 여러 개의 프로세스가 CPU를 사용하기 위해 경쟁할 때, 어떤 프로세스에게 CPU를 할당할지 결정하는 작업이다.

CPU 스케줄러는 운영체제의 일부로, 효율적인 자원 관리를 위해 필요하다.

- CPU 스케줄링의 목표
    1. `공정성(Fairness)` : 모든 프로세스가 CPU 시간을 공평하게 나눠 받아야 한다. 어떤 프로세스도 오랫동안 CPU를 독점해서는 안된다.

    2. `효율성(Efficiency)` : CPU 사용률을 최대화하여 CPU를 최대한 활용해야 한다. 대기 중인 프로세스가 없는 경우 CPU가 놀지 않고 계속해서 작업을 수행해야 한다.

    3. `응답 시간(Response Time)` : 사용자의 입력에 빠르게 응답해야 한다. 응답 시간을 최소화하여 사용자 경험을 향상시켜야 한다.

    4. `턴어라운드 시간(Turnaround Time)` : 프로세스가 시스템에 도착한 시점부터 완료될 때까지 걸리는 시간을 최소화 해야 한다. 프로세스가 빠르게 완료되어야 다음 프로세스가 빠르게 실행될 수 있다.


운영체제는 프로세스의 우선순위를 고려해서 CPU 스케줄링을 하게되는데, 이를 위한 여러가지 알고리즘이 존재한다.

- 대표적인 CPU 스케줄링 알고리즘
    1. `FCFS(First-Come, First-Served)` : 먼저 도착한 프로세스가 먼저 CPU를 할당받는 방식이다. 간단하지만 응답 시간이 길어지는 문제가 있다.

    2. `SJF(Shortest Job First)` : 실행 시간이 가장 짧은 프로세스에게 CPU를 할당하는 방식이다. 응답 시간이 짧고 효율적이다.

    3. `Round Robin` : 공정성을 유지하면서 시분할 시스템을 구현하는 방식이다. 각 프로세스는 일정 시간 동안 CPU를 할당받고, 그 시간이 지나면 다음 프로세스에게 CPU를 넘긴다.

    4. `Priority Scheduling` : 각 프로세스에 우선순위를 할당하고, 우선순위가 높은 프로세스에게 CPU를 할당하는 방식이다.

    5. `Multilevel Queue` : 여러 개의 큐를 사용하여 다양한 우선순위의 프로세스를 구분하고, 각 큐에 다른 스케줄링 알고리즘을 적용하는 방식이다.

### CPU 스케줄링 실습 코드 ###
<details>
<summary>10. cpu_scheduling.py 실습코드 펼쳐보기</summary>

```python

'''
실행전 터미널에서 ps -el | grep python 명령어를 통해 python이라는 이름을 포함한 동작중인 프로세스의 상세내역을 출력해본다.

이후에 파이썬 파일을 실행하고 다시 명령어를 실행해보면 여러개의 프로세스가 추가되어있는 모습을 확인가능하다.

multiprocessing.spwan => 멀티 프로세스에 의해서 돌아가고있음.
multiprocessing-fork => 프로세스 복사시에 fork함수가 사용되었다.

6번째 숫자는 프로세스의 우선순위를 나타내는데 이를 통해 프로세스들의 우선순위가 모두 같은 것을 확인가능하다.

우선순위가 같은 프로세스들을 처리하기 위한 CPU 스케줄링 알고리즘이 존재한다.

'''
from multiprocessing import Process
import os

def func1():
    while True:
        try:
            print("func1 프로세스 아이디: ", os.getpid())
            print("부모 프로세스 아이디: ", os.getppid())
        except KeyboardInterrupt:
            print("KeyboardInterrupt")
            break

def func2():
    while True:
        try:
            print("func2 프로세스 아이디: ", os.getpid())
            print("부모 프로세스 아이디: ", os.getppid())
        except KeyboardInterrupt:
            print("KeyboardInterrupt")
            break

def func3():
    while True:
        try:
            print("func3 프로세스 아이디: ", os.getpid())
            print("부모 프로세스 아이디: ", os.getppid())
        except KeyboardInterrupt:
            print("KeyboardInterrupt")
            break

if __name__ == '__main__':
    print('6.multi_processing3.py 프로세스 아이디: ', os.getpid())
    # 각각 다른 함수를 하위 프로세스로 만든다.
    child1 = Process(target=func1).start() # func1을 하위 프로세스로 만듦
    child2 = Process(target=func2).start() # func2을 하위 프로세스로 만듦
    child3 = Process(target=func3).start() # func3을 하위 프로세스로 만듦
```

</details>
